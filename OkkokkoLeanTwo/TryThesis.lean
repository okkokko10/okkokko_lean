import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {bâ‚, . . . , bâ‚™} âŠ‚ â„â¿ consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where â„ is a field and â„â¿ is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of â„â¿."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define â„â¿, B and Î›

-- btw, this is how a family v : Î¹ â†’ M is coerced into a basis:
#check Module.Basis.mk


variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := Fin n â†’ â„
-- using abbrev makes it so lean automatically recognizes it as `Fin n â†’ â„`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module â„ (Fin n â†’ â„) := Pi.Function.module (Fin n) â„ â„
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module â„ â„`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module â„ â„ := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector â„ n) := by apply?
-- instance : Module â„ (Vector â„ n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul â„ (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module â„ (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n â†’ Rn} (hli: LinearIndependent â„ B)

-- oh yeah, I can just define Î› as the subgroup generated by B
def Î› {B : Fin n â†’ Rn} {_ : LinearIndependent â„ B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Î›.Bc : (Î› hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Î› := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Î› n B hli = @test.Î› n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Î› n B hli) := Î›.toAddCommGroup

-- instance : NormedAddCommGroup (@Î› n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1
namespace s2

open Module

variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := EuclideanSpace â„ (Fin n)

#check ![1 , 2, (3 : â„¤)]
#check !â‚‚[1 , 2, (3 : â„¤)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n â†’ â„) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) â„ (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n â†’ (@Rn n)} (hli: LinearIndependent â„ B) : âŠ¤ â‰¤ Submodule.span â„ (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Î› (B : Basis (Fin n) â„ (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x â†¦ B x

-- abbrev Zn := Fin n â†’ â„¤

abbrev Zn' : Set (Fin n â†’ â„) := Set.range ((Int.cast : â„¤ â†’ â„) âˆ˜ Â·)
-- abbrev Zn'' : Set (Fin n â†’â‚€ â„) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Znâ‚€ : Set (Fin n â†’â‚€ â„) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((â†‘) : â„¤ â†’ â„) âˆ˜ Â·)


lemma Î›.BZ : Î› B = B.repr.symm '' Znâ‚€ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine âŸ¨?_,?_âŸ©
  rw [Î›,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Î› B) := AddSubgroup.toAddCommGroup _

lemma Î›.B_in (i) : B i âˆˆ Î› B := by
  rw [Î›]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Î›.basis : Fin n â†’ Î› B := fun i â†¦ âŸ¨B i,Î›.B_in iâŸ©

-- maybe define Module â„¤ (Î› B)

example : Basis (Fin n) â„¤ (Î› B) := Basis.mk (R := â„¤) (v := Î›.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n â†’ â„ := q
example (q : Î› B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm â„ := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x â†¦ â„

open NNReal

def Î›.minimum_distance (norm : Rn â†’ â„â‰¥0) := â¨… (x âˆˆ (Î› B)) (_ : x â‰  0), norm x

/-
paper:
The minimum distance Î»1(Î›) of a lattice Î› is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Î»1(Î›) = min06=xâˆˆÎ›kxk. More generally, the ith successive
minimum Î»i(Î›) is the smallest radius r such that Î› contains i linearly independent vectors of norm at
most r. We write Î»âˆ
1
to denote the minimum distance measured in the âˆ norm (which is defined as â€–xâ€–âˆ = max |xáµ¢|).
-/
-- i or more
def Î›.successive_minimum_distance (norm : (@Rn n) â†’ â„â‰¥0) (i : â„•)
  := â¨… (r : â„â‰¥0) (_ : âˆƒs âŠ† ((Î› B).carrier), LinearIndependent â„ (Subtype.val : s â†’ Rn) âˆ§ s.encard â‰¤ i âˆ§ âˆ€x âˆˆ s, norm x â‰¤ r), r
-- note: for i := 0 this is âŠ¥ and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) â„ (@Rn n)) := (Î› B) â§¸ (Î› B')
-- example (b : @Rn n) := Î› B â§¸ b
-- example (B' : Basis (Fin n) â„ (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Î› B) := AddSubgroup.normal_of_comm (Î› B)

-- hmm, hold on, paper: "Therefore for lattices Î›' âŠ† Î›,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Î›, since they are also lattices? is that correct? VERIFY

example (Î›' : AddSubgroup (Î› B)) (a b : (Î› B) â§¸ Î›') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Î›' : AddSubgroup (Î› B)) (a : (Î› B) â§¸ Î›') (x) : x âˆˆ a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Î› or â„â¿?

-- is "a basis T of Î›" a `Basis (Fin n) â„¤ (Î› B)`

-- def lemma_2_1 (S : Set (Î› B)) (h : âŠ¤ â‰¤ Submodule.span â„ ((Subtype.val) '' S)) : Basis (Fin n) â„¤ (Î› B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of â„â¿",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Î› has this?
    -- ğ“› is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - âŒŠrâŒ‹ * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n â„) (v : n â†’ â„) := A *áµ¥ v

variable  {Î¹ n : Type*} [Fintype n] (B : Matrix Î¹ n â„)
-- todo: should I assume [Fintype Î¹]? it's going to be true, and a lot relies on it

#check Pi.addMonoidHom
#check Pi.map

#check Pi.instAdd

instance Pi.instAddZero {Î¹ : Type*} {M : Î¹ â†’ Type*}  [(i : Î¹) â†’ AddZero (M i)] : AddZero (âˆ€ i, M i) := {}

-- def Pi_map_addMonoidHom {Î¹ : Type*} {X Y : Î¹ â†’ Type*}  [(i : Î¹) â†’ AddZero (X i)] [(i : Î¹) â†’ AddZero (Y i)] (c : (i : Î¹) â†’ X i â†’+ Y i) : ((i : Î¹) â†’ X i) â†’+ ((i : Î¹) â†’ Y i) where
--   toFun := Pi.map (c Â· Â·)
--   map_zero' := by
--     ext x : 1
--     simp_all only [Pi.map_apply, Pi.zero_apply, map_zero]
--   map_add' := by
--     intro x y
--     ext x_1 : 1
--     simp_all only [Pi.map_apply, Pi.add_apply, map_add]


def int_cast : (Î¹ â†’ â„¤) â†’+ (Î¹ â†’ â„) := (Int.castAddHom â„).compLeft Î¹

-- def int_cast : (Î¹ â†’ â„¤) â†’+ (Î¹ â†’ â„) where
--   toFun := (Int.cast <| Â· Â·)
--   map_zero' := funext fun _ â†¦ Int.cast_zero
--   map_add' := fun x y â†¦ funext fun z â†¦ Int.cast_add (x z) (y z)

@[simp]
theorem int_cast.apply (f : Î¹ â†’ â„¤) : int_cast f = (Int.cast <| f Â·) := rfl

@[simp high]
theorem int_cast.apply_single [DecidableEq Î¹] (i : Î¹) (x) : int_cast (Pi.single i x) = Pi.single i (Int.cast x) := by
  simp
  ext j
  simp only [Pi.single_apply, Int.cast_ite, Int.cast_zero]

example (a : â„¤ â†’+ â„) : â„¤ â†’â‚—[â„¤] â„ := by exact a.toIntLinearMap
#check AddMonoidHom.toIntLinearMap

#check (1 : Matrix â„¤ â„¤ â„)
-- def int_axes (Î¹ : Type*) : Basis Î¹ â„¤ (Î¹ â†’ â„¤) where repr := LinearEquiv.refl
-- def int_axes (Î¹ : Type*) [DecidableEq Î¹] := Set.range (1 : Matrix Î¹ Î¹ â„¤).col
def int_axes (Î¹ : Type*) [Fintype Î¹] [DecidableEq Î¹] : Set (Î¹ â†’ â„¤) := Set.range (Pi.single Â· 1)

-- lemma int_axes.decomposition [Fintype Î¹] [DecidableEq Î¹] : int_axes Î¹

-- #check AddSubgroup.mem_closure_range_iff_of_fintype
theorem int_axes.basis [Fintype Î¹]  [DecidableEq Î¹] : AddSubgroup.closure (int_axes Î¹) = âŠ¤ := by
  ext x
  simp only [AddSubgroup.mem_top, iff_true]
  apply AddSubgroup.mem_closure_range_iff_of_fintype.mpr
  use x
  exact pi_eq_sum_univ' x


-- variable {B' : Matrix}

-- let's revise Zn

def Zn (Î¹ : Type*) : AddSubgroup (Î¹ â†’ â„) := int_cast.range

def Zn.axes (Î¹ : Type*) [Fintype Î¹] [DecidableEq Î¹] : Set (Î¹ â†’ â„) := int_cast '' (int_axes Î¹)

theorem Zn.axes_basis [Fintype Î¹] [DecidableEq Î¹] : AddSubgroup.closure (Zn.axes Î¹) = Zn Î¹ := by
  unfold axes Zn
  rw [AddMonoidHom.range_eq_map,â†int_axes.basis]
  exact Eq.symm (AddMonoidHom.map_closure int_cast (int_axes Î¹))


-- should I generalize further? there was â„¤â‚â¿

#check Pi.intCast_def

-- def Zn.general (Î¹ : Type*) (R : Type*) [IntCast R] : Set (Î¹ â†’ R) := Set.range ((Int.cast : â„¤ â†’ R) âˆ˜ Â·)





#check PMF.bind_map



def ğ“›.ofMatrix (B : Matrix Î¹ n â„) :=  (Zn n).map (B.mulVecLin : (n â†’ â„) â†’+ (Î¹ â†’ â„))


#check B.mulVecLin


theorem ğ“›.ofMatrix_def (B : Matrix Î¹ n â„)
  -- : ğ“›.ofMatrix B = (B.mulVec) '' (Set.range ((Int.cast <| Â· Â·) : (_ â†’ _) â†’ _)) := rfl
  -- : ğ“›.ofMatrix B = Set.range (B.mulVec <| ((Int.cast <| Â· Â·) : (_ â†’ _) â†’ _) Â·) := by
  : ğ“›.ofMatrix B = Set.range (fun x : _ â†’ _ â†¦ B.mulVec (Int.cast <| x Â·) ) := by
    sorry

theorem ğ“›.ofMatrix_def_comp (B : Matrix Î¹ n â„)
  : ğ“›.ofMatrix B = ( (B.mulVecLin.toAddMonoidHom).comp (int_cast) ).range := by
    sorry

theorem Zn.is_ofMatrix  [Fintype Î¹] [DecidableEq Î¹]  : Zn Î¹ = ğ“›.ofMatrix (1 : Matrix Î¹ Î¹ _) := by
  ext x
  simp only [ğ“›.ofMatrix, Matrix.mulVecLin_one, AddSubgroup.mem_map, AddMonoidHom.coe_coe,
    LinearMap.id_coe, id_eq, exists_eq_right]




#check Matrix.mulVec_add

-- todo: note that the function from (Î¹ â†’ â„¤) is a group homomorphism
#check AddMonoidHom

#check Matrix.mulVec.addMonoidHomLeft
#check Matrix.ext_addMonoidHom
-- #check Matrix.addMonoidHom
-- wait I'm an idiot, a matrix as a linear map is Matrix.mulVecLin, I found that already

lemma ğ“›.ofMatrix_is_closure (B : Matrix Î¹ n â„) : ofMatrix B = AddSubgroup.closure (Set.range B.col) := by
  symm
  apply AddSubgroup.closure_eq_of_le
  Â·
    simp [ofMatrix_def_comp]


    intro x âŸ¨xn,xcolâŸ©
    subst xcol
    simp only [Set.mem_range, Function.comp_apply, Matrix.mulVecBilin_apply]

    open scoped Classical in
    use Pi.single xn 1
    simp only [int_cast.apply_single, Int.cast_one, Matrix.mulVec_single, MulOpposite.op_one,
      one_smul]
  simp [ofMatrix]



  sorry

-- theorem ğ“›.ofMatrix_def {Î¹ n} [Fintype n] (B : Matrix Î¹ n â„) : ğ“›.ofMatrix B = (B.mulVec : (n â†’ â„) â†’ (Î¹ â†’ â„)) '' (Zn n)

#check Matrix.mulVec_add


-- todo: note that the function from (Î¹ â†’ â„¤) is a group homomorphism
#check AddHom

#check Basis
#check Submodule
#check Submodule.traceDual
-- #check Submodule.traceDual
#check Algebra
-- #check Matrix.mulVec
example : Algebra â„¤ â„ := by exact Ring.toIntAlgebra â„
#check IsScalarTower
#check Polynomial

#check dotProductEquiv
#check Dual -- not the same as dual lattice

open Function

-- def ğ“›.dualLattice {Î¹ : Type*} [Fintype Î¹] (Î› : Set (Î¹ â†’ â„)) := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, dotProduct x v âˆˆ Set.range (Int.cast)}
#check neg_involutive
#check Function.Involutive


#check AddSubgroup.map -- use to define ğ“›.ofMatrix

-- #check Real
#check Dual

-- theorem ğ“›.dualLattice_basis  {Î¹ n : Type*} [Fintype Î¹] [Fintype n] (B : Matrix Î¹ n â„)
--   : ğ“›.dualLattice (ğ“›.ofMatrix B) = { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Set.range (B.col), dotProduct x v âˆˆ Set.range (Int.cast)} := by
--   sorry

-- wait, sublattices are still n-dimensional? see Corollary 2.8
-- ah, I see. for example 2*Î› is a sublattice of Î›, but Î› with a basis vector removed is not
-- no, nevermind. MG02 defines

#check HomogeneousSubmodule
#check HomogeneousIdeal
#check DirectSum
#check DirectSum.Decomposition
#check Algebra
#check Submodule.IsOrtho
#check Submodule.orthogonal
-- ^^^ would be a subset of a lattice, but it needs [RCLike ğ•œ]
#check Orthonormal
#check GradedRing

#check TopologicalSpace
def ğ“›.IsLattice (Î› : AddSubgroup (Î¹ â†’ â„)) : Prop := sorry


def ğ“›.dualLattice_general {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (Î› : AddSubgroup (Î¹ â†’ â„))  : AddSubgroup (Î¹ â†’ â„) where
  carrier := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, x â¬áµ¥ v âˆˆ S}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]



def ğ“›.dualLattice {Î¹ : Type*} [Fintype Î¹] (Î› : AddSubgroup (Î¹ â†’ â„)) : AddSubgroup (Î¹ â†’ â„) := dualLattice_general (Int.castAddHom â„ |>.range) Î›


#check Basis.addHaar


theorem ğ“›.dualLattice_involutive  {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) : Involutive (ğ“›.dualLattice_general (Î¹ := Î¹) S) := by
  -- unfold Involutive
  intro Î›

  -- let p (r : â„) := (r âˆˆ S)
  -- let h (v u : Î¹ â†’ â„) := p (v â¬áµ¥ u)


  set Î›' := dualLattice_general S Î› with back

  ext x
  rw [AddSubgroup.ext_iff] at back

  unfold dualLattice_general at back âŠ¢
  change (âˆ€ v âˆˆ Î›', x â¬áµ¥ v âˆˆ S) â†” x âˆˆ Î›
  change âˆ€v, v âˆˆ Î›' â†” âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S at back
  simp_rw [dotProduct_comm x _]
  refine âŸ¨?_,fun xL v vL' â†¦ (back v).mp vL' x xLâŸ©

  intro fo

  have : âˆ€v, v âˆˆ Î›' â†’ âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S := by exact fun v a x a_1 â†¦ a x a_1
  have t2: âˆ€v, (âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S) â†’ v âˆˆ Î›' := by exact fun v a â†¦ this v (this v (this v (this v a)))

  --  `âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S` means the preimage of (v â¬áµ¥) over S contains Î›
  -- or that the image over Î› is in S
  #check AddMonoidHom.range

  let qq (x : Î¹ â†’ â„) := (dotProductBilin â„¤ â„¤ x).toAddMonoidHom

  have nne (v : Î¹ â†’ â„): (âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S) â†” Î›.map (qq v) â‰¤ S := by
    simp [qq]
    constructor
    intro eer
    exact AddSubgroup.map_le_iff_le_comap.mpr (this v (this v (this v (this v eer))))
    intro xee x xL
    rw [AddSubgroup.map_le_iff_le_comap] at xee
    simp_all only [implies_true, Î›']
    apply xee
    simp_all only
  simp_all only [implies_true]

  sorry

--

example {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (Î›_basis : Set (Î¹ â†’ â„))
  : { x : Î¹ â†’ â„ | âˆ€ v âˆˆ AddSubgroup.closure (Î›_basis), x â¬áµ¥ v âˆˆ S}
  = { x : Î¹ â†’ â„ | âˆ€ v âˆˆ (Î›_basis), x â¬áµ¥ v âˆˆ S}
  := by
  ext x
  simp only [Set.mem_setOf_eq]

  sorry

-- try dual lattice as a comap

#check dotProductBilin
#check dotProductBilin_apply_apply
#check AddSubgroup.comap
#check dotProductBilin â„¤ â„¤

example {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (v : Î¹ â†’ â„)
  : {x | v â¬áµ¥ x âˆˆ S} = (v â¬áµ¥ Â·) â»Â¹' S
  := by rfl
example {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (v : Î¹ â†’ â„)
  : {x | v â¬áµ¥ x âˆˆ S} = (S.comap (dotProductBilin â„¤ â„¤ v)).carrier
  := by rfl

example {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (Î›_basis : Set (Î¹ â†’ â„))
  : { x : Î¹ â†’ â„ | âˆ€ v âˆˆ (Î›_basis), v â¬áµ¥ x âˆˆ S}
  = â¨… v âˆˆ Î›_basis, (S.comap (dotProductBilin â„¤ â„¤ v)).carrier
  := by
    ext x
    simp only [Set.mem_setOf_eq, Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]


example {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (Î›_basis : Finset (Î¹ â†’ â„))
  : â¨… v âˆˆ Î›_basis, ((S.comap (dotProductBilin â„¤ â„¤ v)) : AddSubgroup (Î¹ â†’ â„)).carrier
  = (â¨… v âˆˆ Î›_basis, S.comap (dotProductBilin â„¤ â„¤ v)).carrier
  := by
    ext x
    simp only [Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]
    constructor
    intro xw ew âŸ¨G,erâŸ©
    simp_all
    subst er
    simp only [Set.mem_iInter, SetLike.mem_coe]
    intro y eg
    sorry
    sorry

example [Fintype Î¹]  (S : AddSubgroup â„)
  : { x : Î¹ â†’ â„ | âˆ€ v âˆˆ ğ“›.ofMatrix B, v â¬áµ¥ x âˆˆ S}
  = { x : Î¹ â†’ â„ | âˆ€ z âˆˆ (Zn n), ((B.mulVecLin : (n â†’ â„) â†’+ (Î¹ â†’ â„)) z) â¬áµ¥ x âˆˆ S}
  := by
    unfold ğ“›.ofMatrix
    simp only [AddSubgroup.mem_map, AddMonoidHom.coe_coe, Matrix.mulVecBilin_apply,
      forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚]


example [Fintype Î¹]  (S : AddSubgroup â„)
  : { x : Î¹ â†’ â„ | âˆ€ v âˆˆ ğ“›.ofMatrix B, v â¬áµ¥ x âˆˆ S}
  = { x : Î¹ â†’ â„ | âˆ€ z âˆˆ (Zn n), dotProductBilin â„¤ â„¤ ((B.mulVecLin) z) x âˆˆ S}
  := by
    calc
      {x | âˆ€ v âˆˆ ğ“›.ofMatrix B, v â¬áµ¥ x âˆˆ S} = {x | âˆ€ z âˆˆ Zn n, ((dotProductBilin â„¤ â„¤) (B.mulVecLin z)) x âˆˆ S} := sorry
      _ = {x | âˆ€ z âˆˆ Zn n, ((dotProductBilin â„¤ â„¤) (B.mulVecLin z)) x âˆˆ S} := by rfl
      _ = {x | âˆ€ z âˆˆ Zn n, ((dotProductBilin â„¤ â„¤).toAddMonoidHom.comp (B.mulVecLin)) z x âˆˆ S} := sorry
      _ = {x | âˆ€ z âˆˆ Zn n, ((dotProductBilin â„¤ â„¤) (B.mulVecLin z)) x âˆˆ S} := sorry

-- right, if all the basis vectors dotprod to â„¤ then the matrix muls to â„¤â¿

open ProbabilityTheory
open MeasureTheory

#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianPDF


def gaussian [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) (s : â„â‰¥0) (x : Î¹ â†’ â„) := ProbabilityTheory.gaussianPDF 0 s â€–x - câ€–


#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.isGaussian_map

#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianReal _ _ |>.map

#check MeasureTheory.Measure.comap
#check MeasureTheory.Measure.comap_apply

-- we have a function Rn â†’ â„, and a measure on â„

example [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) (s : â„â‰¥0) : gaussian c s = ProbabilityTheory.gaussianPDF 0 s âˆ˜ (â€–Â· - câ€–) := by rfl

#check ProbabilityTheory.gaussianReal
#check MeasureTheory.Measure.withDensity
#check MeasureTheory.Measure.compProd_withDensity
-- look for theorems on this
#check MeasureTheory.pdf_def


#check MeasureTheory.withDensity_pdf_le_map

#check MeasureTheory.pdf

-- nope
example [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) (s : â„â‰¥0) := (ProbabilityTheory.gaussianReal 0 s).comap (â€–Â· - câ€–) -- nope, not injective.

#check MeasureTheory.pdf



def gaussianMeasure [Fintype Î¹] [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) (s : â„â‰¥0) := volume.withDensity (gaussianPDF 0 s âˆ˜ (â€–Â· - câ€–))
def gaussianMeasure' [Fintype Î¹] [Norm (Î¹ â†’ â„)] (Î› : AddSubgroup (Î¹ â†’ â„)) (c : Î¹ â†’ â„) (s : â„â‰¥0) := gaussianMeasure c s |>.restrict Î›

def gaussianMeasure'' [Fintype Î¹] [Norm (Î¹ â†’ â„)] (Î› : AddSubgroup (Î¹ â†’ â„))  (c : Î¹ â†’ â„) (s : â„â‰¥0)
  := (gaussianMeasure' Î› c s Set.univ)â»Â¹ â€¢ (gaussianMeasure' Î› c s)


-- is this true?
-- example  [Fintype Î¹] [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) (s : â„â‰¥0) : IsGaussian (gaussianMeasure'' c s) := by sorry

#check IsGaussian.toIsProbabilityMeasure

#check IsGaussian.map_eq_gaussianReal



--oh, I found a lattice definition
#check IsZLattice

end s2

namespace s3

open scoped NNReal ENNReal


#check IsZLattice
#check Submodule.IsLattice

abbrev Basis (Î¹ : Type*) [Fintype Î¹] := Module.Basis Î¹ â„ (Î¹ â†’ â„)

variable {Î¹ : Type*} [Fintype Î¹] (B : Basis Î¹)
variable (Î› : Submodule â„¤ (Î¹ â†’ â„)) [DiscreteTopology Î›] [IsZLattice â„ Î›]

section lattices

abbrev ğ“› := Submodule.span â„¤ (Set.range B)

-- example :=

example : DiscreteTopology (ğ“› B) := ZSpan.instDiscreteTopologySubtypeMemSubmoduleIntSpanRangeCoeBasisRealOfFinite B
example : IsZLattice â„ (ğ“› B) := by infer_instance
example : Basis Î¹ := (IsZLattice.basis Î›).ofZLatticeBasis â„

def dualLattice_basic : AddSubgroup (Î¹ â†’ â„) where
  carrier := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, x â¬áµ¥ v âˆˆ (Int.castAddHom â„ |>.range)}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]

def dualLattice : Submodule â„¤ (Î¹ â†’ â„) := (dualLattice_basic Î›).toIntSubmodule

theorem dualLattice.involution : Function.Involutive (dualLattice (Î¹ := Î¹)) := sorry

-- #check ZSpan

def minimum_distance [Norm (Î¹ â†’ â„)] := â¨… (x âˆˆ Î›) (_ : x â‰  0), â€–xâ€–

/-
paper:
The minimum distance Î»1(Î›) of a lattice Î› is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Î»1(Î›) = min06=xâˆˆÎ›kxk. More generally, the ith successive
minimum Î»i(Î›) is the smallest radius r such that Î› contains i linearly independent vectors of norm at
most r. We write Î»âˆ
1
to denote the minimum distance measured in the âˆ norm (which is defined as â€–xâ€–âˆ = max |xáµ¢|).
-/
-- i or more
def successive_minimum_distance [Norm (Î¹ â†’ â„)] (i : â„•)
  := â¨… (r : â„â‰¥0) (_ : âˆƒs âŠ† (Î›.carrier), LinearIndependent â„ (Subtype.val : s â†’ _) âˆ§ s.encard â‰¤ i âˆ§ âˆ€x âˆˆ s, â€–xâ€– â‰¤ r), r
-- note: for i := 0 this is âŠ¥ and i := 1 this is 0
def successive_minimum_distance' [Norm (Î¹ â†’ â„)] (i : â„•)
  := â¨… (s âŠ† (Î›.carrier)) (_ : LinearIndependent â„ (Subtype.val : s â†’ _)) (_ : s.encard â‰¤ i), â¨†x âˆˆ s, â€–xâ€–

-- def dualLattice

end lattices

section gaussians

open ProbabilityTheory
open MeasureTheory


def gaussianFunction [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (_ : s â‰  0) (c : Î¹ â†’ â„)  := gaussianPDF 0 s âˆ˜ (â€–Â· - câ€–)

#check MeasureTheory.Measure.count
-- #check Measure.comap

#check gaussianReal
/-
2.4 Gaussians on Lattices
Ï s c
-/
def gaussianMeasure [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  (c : Î¹ â†’ â„) := Measure.count.withDensity (gaussianFunction hs c)

#check ProbabilityMeasure


def gaussianMeasure' [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0) (c : Î¹ â†’ â„)  := (gaussianMeasure hs c).restrict Î›


lemma gaussianMeasure'_finite [Norm (Î¹ â†’ â„)]  {s : â„â‰¥0} (hs : s â‰  0)  (c : Î¹ â†’ â„) : IsFiniteMeasure (gaussianMeasure' Î› hs c) := sorry
-- def gaussianMeasure'_total [Norm (Î¹ â†’ â„)] (c : Î¹ â†’ â„) {s : â„â‰¥0} (hs : s â‰  0) := (gaussianMeasure' Î› c hs) Set.univ

-- def gaussianDistribution [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  (c : Î¹ â†’ â„) := ((gaussianMeasure' Î› hs c) Set.univ)â»Â¹ â€¢ gaussianMeasure' Î› hs c
def gaussianDistribution [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  (c : Î¹ â†’ â„) := (gaussianMeasure' Î› hs c)[|Set.univ]

lemma gaussianDistribution_prob [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0) (c : Î¹ â†’ â„) : IsProbabilityMeasure (gaussianDistribution Î› hs c) := by
  unfold gaussianDistribution
  -- refine cond_isProbabilityMeasure ?_
  refine isProbabilityMeasure_iff.mpr ?_
  simp only [ProbabilityTheory.cond, Measure.restrict_univ, Measure.smul_apply, smul_eq_mul]
  refine ENNReal.inv_mul_cancel ?_ ?_
  -- todo: make its own theorem
  simp only [ne_eq, Measure.measure_univ_eq_zero]
  intro gm
  rw [Measure.ext_iff] at gm
  specialize gm {0}
  simp only [MeasurableSet.singleton, Measure.coe_zero, Pi.ofNat_apply, forall_const] at gm
  unfold gaussianMeasure' gaussianMeasure at gm
  have : {0} âˆ© (Î› : Set (Î¹ â†’ â„)) = {0} := by
    rw [Set.inter_eq_left, Set.singleton_subset_iff, SetLike.mem_coe]
    exact zero_mem Î›

  simp only [MeasurableSet.singleton, Measure.restrict_apply, this, withDensity_apply,
    Measure.restrict_singleton, Measure.count_singleton', one_smul, lintegral_dirac] at gm
  unfold gaussianFunction gaussianPDF at gm
  simp at gm
  revert gm
  simp only [imp_false, not_le]
  exact gaussianPDFReal_pos _ _ _ hs

  have := gaussianMeasure'_finite Î› hs c
  exact this.1.ne


lemma gaussianDistribution.eq [Norm (Î¹ â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  (c : Î¹ â†’ â„)
  : gaussianDistribution Î› hs c = (gaussianMeasure hs c)[|Î›] := by
    unfold gaussianDistribution gaussianMeasure'
    simp only [ProbabilityTheory.cond, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter,
      Measure.restrict_univ]


def int_gaussian_real_measure (m) [Norm (Fin m â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  : Measure (Fin m â†’ â„)
  :=
  gaussianDistribution (AddSubgroup.toIntSubmodule (s2.Zn (Fin m))) hs 0



-- def int_gaussian_int_measure (m) [Norm (Fin m â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  : Measure (Fin m â†’ â„¤)
--   :=  (gaussianMeasure hs 0)[| (s2.Zn (Fin m))].comap ((â†‘) âˆ˜ Â·)
def int_gaussian_int_measure (m) [Norm (Fin m â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0) (c : Fin m â†’ â„)  : Measure (Fin m â†’ â„¤)
  :=  ((gaussianMeasure hs c).comap ((Int.cast : â„¤ â†’ â„) âˆ˜ Â·))[|Set.univ]

/-- D_{Záµ,s} -/
def int_gaussian  (m) [Norm (Fin m â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0)  : ProbabilityMeasure (Fin m â†’ â„¤) :=
  âŸ¨
    int_gaussian_int_measure m hs 0
    , sorry
  âŸ©

def int_gaussian_sublattice  (m) [Norm (Fin m â†’ â„)] {s : â„â‰¥0} (hs : s â‰  0) (Î› : AddSubgroup (Fin m â†’ â„¤)) (c : Fin m â†’ â„¤) : ProbabilityMeasure (Fin m â†’ â„¤) :=
  âŸ¨
    (int_gaussian_int_measure m hs ((â†‘) âˆ˜ c))[|Î›]
    , sorry
  âŸ©


end gaussians

/--
Î·
-/
def smoothing_parameter {Îµ : â„â‰¥0} (_ : Îµ â‰  0)
  := â¨… (s : â„â‰¥0) (hs : s â‰  0) (_ : (gaussianMeasure' (dualLattice Î›) (show sâ»Â¹ â‰  0 by simp only [ne_eq,
    inv_eq_zero, hs, not_false_eq_true]) 0) (Set.compl {0}) â‰¤ Îµ), s

def infinity_norm : Norm (Î¹ â†’ â„) := Pi.normedAddGroup.toNorm

-- justifies changing infinity_norm
example {Î¹} [Fintype Î¹] : (âŸ¨fun x â†¦ (PiLp.instNorm âˆ (fun (_ : Î¹) â†¦ â„)).norm (WithLp.toLp âˆ x)âŸ© : Norm (Î¹ â†’ â„)) = Pi.normedAddGroup.toNorm := by
  simp only [PiLp.norm_toLp]

/-- Î»â‚âˆ -/
def minimum_distance_sup  := @minimum_distance Î¹ Î› (infinity_norm)

-- what log base?
theorem Lemma_2_6 {Îµ : â„â‰¥0} (he : Îµ â‰  0)
  : smoothing_parameter Î› he â‰¤
  âˆš (Real.log (2 * Fintype.card Î¹ / (1 + Îµâ»Â¹)) / Real.pi)
  / minimum_distance_sup Î› := sorry

#check EuclideanSpace

-- todo: Norm is just a notation class. theorems about defs using it need [NormedAddCommGroup]
#check NormedAddCommGroup

#check ForIn

#check Monad

def SampleD {n : â„•} {m : â„•} (hn : 0 < n) (gs_b : Basis (Fin n)) (s : â„â‰¥0) (hs : s â‰  0) (center : (Fin n) â†’ â„) (DZ : {s' : â„ // s' > 0} â†’ â„ â†’ PMF (â„¤)) : PMF ( Fin n â†’ â„)  := do {
  let mut v : ((Fin n) â†’ â„)  := 0;
  let mut c : ((Fin n) â†’ â„) := center;

  for hi : i in (Vector.range n).reverse do
    let fi : Fin n := âŸ¨i,(Vector.mem_range.mp (Vector.mem_reverse.mp hi))âŸ©
    let bi := gs_b fi
    let c'i : â„ := (c â¬áµ¥ bi) / (bi â¬áµ¥ bi);
    let s'i : â„ := s / â€–biâ€–;
    have : s'i > 0 := by sorry;
    -- step (b)
    let zi â† (DZ âŸ¨s'i,thisâŸ© c'i);
    -- step (c)
    c := (c - zi â€¢ bi)
    v := (v + zi â€¢ bi)

  return v
}

#check Asymptotics.IsLittleO
open Asymptotics MeasureTheory
open ProbabilityTheory
#check â„™

-- f(x) = Ï‰(g(x))
notation:100 f " =Ï‰[" l "] " g:100 => g =o[l] f

def negligible {R : Type*} [Norm R] (f : â„• â†’ R) := âˆ€(c : â„•), c > 0 â†’ f =o[Filter.atTop] (fun (n : â„•) â†¦ (n : â„) ^ (-(c : â„)))

-- #check ProbabilityTheory.HasPDF
#check MeasureTheory.pdf

--- [https://www.cs.bu.edu/~reyzin/teaching/s11cs937/notes-leo-1.pdf]


#check PMF


#check MeasureTheory.SignedMeasure.totalVariation -- Gemini found this.


-- I need to explain this
def statistical_distance' {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D) := (2â»Â¹) * (SignedMeasure.totalVariation (X.toMeasure.toSignedMeasure - Y.toMeasure.toSignedMeasure)) Set.univ
lemma statistical_distance_finite_1 {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D)
  : IsFiniteMeasure ((X.toMeasure.toSignedMeasure - Y.toMeasure.toSignedMeasure).totalVariation) := isFiniteMeasureAdd
lemma statistical_distance_finite_2 {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D)
  : statistical_distance' X Y < âˆ := by
    unfold statistical_distance'
    refine ENNReal.mul_lt_top ?_ ?_
    simp only [ENNReal.inv_lt_top, Nat.ofNat_pos]
    simp only [statistical_distance_finite_1, measure_lt_top]
def statistical_distance {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D) : â„â‰¥0 := statistical_distance' X Y |>.toNNReal

instance : Norm â„â‰¥0 := âŸ¨(â†‘)âŸ©


def statistically_close {D : (n : â„•) â†’  Type*} [âˆ€n, MeasurableSpace (D n)] (X Y : (n : â„•) â†’ ProbabilityMeasure (D n)) :=
  negligible (fun n â†¦ statistical_distance (X n) (Y n))


-- theorem lemma_5_1 {m : â„â‰¥0} {_ : 2 * n }

-- #check Mathlib.Testing.SlimCheck

def mHyp (m n q : â„•) : Prop := (2 * n * Real.log q) â‰¤ m

def sqrt_log : â„• â†’ â„ := (Real.sqrt âˆ˜  Real.log âˆ˜ (â†‘))
def Ï‰_sqrt_log (Ï‰ : â„• â†’ â„â‰¥0) : Prop := Ï‰ =Ï‰[Filter.atTop] sqrt_log


-- #check ZMod 2
-- def mod_q ( q : â„•) := â„¤ â§¸ (AddSubgroup.closure {(q : â„¤)})
-- lemma mod_q.isFinite {q : â„•} : Finite (ZMod q) := by
--   apply?
--   sorry

-- seems like Fin q is the integers mod q
#eval (7 : Fin 6)
-- ZMod q is Fin q if q is positive

-- abbrev mod_q ( q : â„•) := ZMod q

-- again, does Î› vary over n?
theorem Lemma_2_6_then
  (Ï‰ : (n : â„•) â†’ â„â‰¥0) (hÏ‰ : Ï‰_sqrt_log Ï‰)
  : âˆƒ(Îµ : (n : â„•) â†’ â„â‰¥0) (negl_Îµ : negligible Îµ) (Îµ_pos : âˆ€i, Îµ i â‰  0), âˆ€i,
  smoothing_parameter Î› (Îµ_pos i) â‰¤ Ï‰ i / minimum_distance_sup (dualLattice Î›)
  := sorry
theorem Lemma_2_6_then'
  {Î¹ : (n : â„•) â†’ Type*} [âˆ€n, Fintype (Î¹ n)] (Î› : (n : â„•) â†’ Submodule â„¤ ((Î¹ n) â†’ â„)) [âˆ€n, DiscreteTopology â†¥(Î› n)] [âˆ€n, IsZLattice â„ (Î› n)]
  (Ï‰ : (n : â„•) â†’ â„â‰¥0) (hÏ‰ : Ï‰_sqrt_log Ï‰)
  : âˆƒ(Îµ : (n : â„•) â†’ â„â‰¥0) (negl_Îµ : negligible Îµ) (Îµ_pos : âˆ€n, Îµ n â‰  0), âˆ€n,
  smoothing_parameter (Î› n) (Îµ_pos n) â‰¤ Ï‰ n / minimum_distance_sup (dualLattice (Î› n))
  := by
    have other n := Lemma_2_6_then (Î› n) Ï‰ hÏ‰
    have t n := other n |>.choose n
    use t

    sorry

-- note: NeZero allows this to be inferred, while h : q > 0 doesn't
example  {q : â„•} [NeZero q] : Finite (ZMod q) := inferInstance

-- instance {q : â„•} : Zero (ZMod q) where zero := 0

def A_Matrix (n m q : â„•) : Type := Matrix (Fin n) (Fin m) (ZMod q)

instance A_Matrix.instFinite {n m q : â„•} [NeZero q] : Finite (A_Matrix n m q) := Matrix.instFinite (ZMod q)
instance {n m q : â„•} [NeZero q] : Nonempty (A_Matrix n m q) := Equiv.nonempty Matrix.of.symm

-- set_option trace.Meta.synthInstance true in
example (q)  [NeZero q] : Algebra â„¤ (ZMod q) := inferInstance

def toZModLin (q) : â„¤ â†’â‚—[â„¤] (ZMod q) := Algebra.linearMap â„¤ (ZMod q)

#eval
  (List.range 10).map ((â†‘) : _ â†’ â„¤) |>.map (toZModLin 3)

def A_Matrix.syndrome_map {n m q : â„•} (A : A_Matrix n m q) : (Fin m â†’ â„¤) â†’â‚—[â„¤] (Fin n â†’ ZMod q) := by
  -- have := Matrix.toLin (m := Fin n) (n := Fin m) (R := ZMod q) sorry sorry
  let vl:= Matrix.mulVecLin A
  -- have this be â†’â‚—[â„¤] as well
  -- is converting to ZMod q the same before or after "this"?
  let : (Fin m â†’ â„¤) â†’â‚—[â„¤] (Fin m â†’ ZMod q) := by
    exact (toZModLin q).compLeft (Fin m)
  exact Fintype.linearCombination â„¤ fun a a_1 â†¦ A a_1 a

  -- refine ((LinearMap.comp this vl) )


-- this shows that modulo can be done before or after
example (q : â„•) (a b : â„¤) : ((a : ZMod q) * (b : ZMod q)) = â†‘(a * b) := by
  simp only [Int.cast_mul]

def A_Matrix.syndrome_map' {n m q : â„•} (A : A_Matrix n m q) : (Fin m â†’ â„¤) â†’ (Fin n â†’ ZMod q) := by
  intro x
  apply A.mulVec <| Int.cast âˆ˜ x

section testing
open Plausible



instance {q} : Arbitrary (ZMod q) :=
  match q with
    | 0 => Int.Arbitrary
    | _ + 1 => Fin.Arbitrary
instance {q} : Shrinkable (ZMod q) :=
  match q with
    | 0 => Int.shrinkable
    | _ + 1 => Fin.shrinkable
#test âˆ€i : (ZMod 5), i + 0 = i
#test âˆ€i : (Fin 2 â†’ Fin 2), i + 0 = i

-- experimentally checks that syndrome_map is correct
#eval Testable.check
    (âˆ€ ee : _ â†’ _ â†’ (ZMod _),
    let A : A_Matrix 3 4 5 := Matrix.of ee;
    âˆ€xx, A.syndrome_map xx = A.syndrome_map' xx)
  {traceSuccesses := true}



end testing

#check DiscreteMeasurableSpace
-- #check OpensMeasurableSpace

instance A_Matrix.instMeasurableSpace (n m q : â„•) [NeZero q] : MeasurableSpace (A_Matrix n m q) := âŠ¤
example (n m q : â„•) [NeZero q] : DiscreteMeasurableSpace (A_Matrix n m q) := inferInstance

def A_Matrix.uniform {n m q : â„•} [NeZero q] : ProbabilityMeasure (A_Matrix n m q) :=
  âŸ¨ProbabilityTheory.uniformOn Set.univ,
  ProbabilityTheory.uniformOn_isProbabilityMeasure Set.finite_univ Set.univ_nonemptyâŸ©

instance {n m q : â„•} [NeZero q] : MeasureSpace (A_Matrix n m q) where
  volume := @A_Matrix.uniform n m q _


def uniform_over_Zqn (n q : â„•) [NeZero q] : ProbabilityMeasure (Fin n â†’ ZMod q) :=
  âŸ¨ProbabilityTheory.uniformOn Set.univ,
  ProbabilityTheory.uniformOn_isProbabilityMeasure Set.finite_univ Set.univ_nonemptyâŸ©

#check ProbabilityTheory.uniformOn_univ


#check int_gaussian


-- "the subset-sums of the columns of A generate Zqn"
def lemma_5_1_statement {n m q : â„•} (A : A_Matrix n m q) : Prop :=
  A.syndrome_map '' {e | âˆ€i, e i = 0 âˆ¨ e i = 1} = Set.univ

-- the form seems complete
-- wait, is q_prime
theorem lemma_5_1 {n m q : â„•} [NeZero q]  (q_prime : Nat.Prime q) (m_hyp : mHyp m n q) : â„™ (lemma_5_1_statementá¶œ : Set <| A_Matrix n m q) â‰¤ (q ^ (- n : â„)) := sorry

-- {e | Ae mod q = 0 }
def A_Matrix.Î›_ortho {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : AddSubgroup (Fin m â†’ â„¤) := A.syndrome_map.toAddMonoidHom.ker

-- does it matter that this is ZMod q?
-- I wonder, a philosophical idea about a sense in which â„• is equivalent to {0 mod 2, 1 mod 2}
def A_Matrix.Î›_main_base {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : AddSubgroup (Fin m â†’ ZMod q) := (A_Matrix.syndrome_map (A.transpose : A_Matrix m n q)).toAddMonoidHom.range
def A_Matrix.Î›_main {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : AddSubgroup (Fin m â†’ â„¤)
  := (A_Matrix.syndrome_map A.transpose).toAddMonoidHom.range.comap
  ((Int.castAddHom (ZMod q)).compLeft (Fin m))

def to_R {m} (L : AddSubgroup (Fin m â†’ â„¤) ) : Submodule â„¤ (Fin m â†’ â„) := (AddSubgroup.map ((Int.castAddHom â„).compLeft (Fin m)) L).toIntSubmodule

def A_Matrix.Î›_ortho' {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : Submodule â„¤ (Fin m â†’ â„) := to_R A.Î›_ortho
def A_Matrix.Î›_main' {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : Submodule â„¤ (Fin m â†’ â„) := to_R A.Î›_main

theorem A_Matrix.Î›_dual {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  -- (to_R A.Î›_ortho) = (q : â„¤) â€¢ (dualLattice <| to_R A.Î›_main)
  (A.Î›_ortho') = (dualLattice <| A.Î›_main').map (LinearMap.lsmul â„¤ _ q)
  := by sorry
theorem A_Matrix.Î›_dual' {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  (A.Î›_main') = (dualLattice <| A.Î›_ortho').map (LinearMap.lsmul â„¤ _ q)
  := by sorry

lemma A_Matrix.Î›_ortho'.has_qZn {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  âˆ€i, Pi.single i q âˆˆ (A.Î›_ortho') := by
    intro i
    refine (Submodule.mem_toAddSubgroup A.Î›_ortho').mp ?_
    unfold Î›_ortho' to_R
    simp only [AddSubgroup.toIntSubmodule_toAddSubgroup, AddSubgroup.mem_map]
    unfold Î›_ortho
    simp only [AddMonoidHom.mem_ker, LinearMap.toAddMonoidHom_coe]
    use Pi.single i q
    constructor
    {
      ext j
      unfold syndrome_map
      simp only [Fintype.linearCombination_apply_single, Pi.smul_apply, zsmul_eq_mul,
        Int.cast_natCast, CharP.cast_eq_zero, zero_mul, Pi.zero_apply]
    }
    ext j
    simp only [AddMonoidHom.compLeft_apply, Int.coe_castAddHom, Function.comp_apply]
    by_cases h : i = j
    subst h
    simp only [Pi.single_eq_same, Int.cast_natCast]
    simp only [ne_eq, h, not_false_eq_true, Pi.single_eq_of_ne', Int.cast_zero]





#check instIsZLatticeComap
#check Submodule.IsLattice

instance A_Matrix.Î›_ortho'.instDiscreteTopology {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  DiscreteTopology â†¥(A.Î›_ortho') := sorry
instance A_Matrix.Î›_ortho'.instIsZLattice {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  IsZLattice â„ (A.Î›_ortho') := sorry
instance A_Matrix.Î›_main'.instDiscreteTopology {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  DiscreteTopology â†¥(A.Î›_main') := sorry
instance A_Matrix.Î›_main'.instIsZLattice {n m q : â„•} [NeZero q] (A : A_Matrix n m q) :
  IsZLattice â„ (A.Î›_main') := sorry

def A_Matrix.syndrome_distributed {n m q : â„•} [NeZero q] (A : A_Matrix n m q)
  (e : ProbabilityMeasure (Fin m â†’ â„¤))
  := e.map (f := A.syndrome_map) (AEMeasurable.of_discrete)

theorem lemma_5_2 {n m q : â„•} [NeZero q] (A : A_Matrix n m q) (ass : lemma_5_1_statement A)
  (Îµ : â„â‰¥0) (Îµ_pos : Îµ â‰  0) (Îµ_bound : Îµ < 2â»Â¹) (s : â„â‰¥0) [Fintype (Fin m)]
  (s_prop : s â‰¥ smoothing_parameter (A.Î›_ortho') Îµ_pos) :
  let hs : s â‰  0 := sorry;
  statistical_distance (A.syndrome_distributed (int_gaussian m hs)) (uniform_over_Zqn _ _) â‰¤ 2 * Îµ
  := sorry

theorem lemma_5_2_furthermore {n m q : â„•} [NeZero q] (A : A_Matrix n m q) (ass : lemma_5_1_statement A)
  (Îµ : â„â‰¥0) (Îµ_pos : Îµ â‰  0) (Îµ_bound : Îµ < 2â»Â¹) (s : â„â‰¥0) [Fintype (Fin m)]
  (s_prop : s â‰¥ smoothing_parameter (A.Î›_ortho') Îµ_pos) (u : Fin n â†’ ZMod q) (t : Fin m â†’ â„¤) (ht : A.syndrome_map t = u)
  :
  let hs : s â‰  0 := sorry;
  -- ProbabilityTheory.cond (int_gaussian m hs) (A.syndrome_map â»Â¹' {u}) = t +áµ¥ (int_gaussian_sublattice m hs A.Î›_ortho (-t))
  ProbabilityTheory.cond (int_gaussian m hs) (A.syndrome_map â»Â¹' {u}) = (int_gaussian_sublattice m hs A.Î›_ortho (-t)).map (f := (Â· + t)) (AEMeasurable.of_discrete)
  := sorry


def lemma_5_3_statement {n m q : â„•} [NeZero q] (A : A_Matrix n m q) : Prop :=
  minimum_distance_sup (A.Î›_main') â‰¥ q/4

abbrev N := â„•
abbrev M := â„•
abbrev Q := â„•

def mHyp' (m : N â†’ M) (q : N â†’ Q) : Prop := âˆ€n, (2 * n * Real.log (q n)) â‰¤ m n

lemma mHyp'_linear (m : N â†’ M) (q : N â†’ Q) (q_prime : âˆ€n, Nat.Prime (q n)) (m_hyp : mHyp' m q) : id â‰¤ m :=
  by
  unfold mHyp' at m_hyp
  intro n
  dsimp only [id_eq]
  specialize m_hyp n
  rify
  apply le_trans ?_ m_hyp
  have t n : 2 â‰¤ (q n : â„) := by
    simp only [Nat.ofNat_le_cast]
    apply Nat.Prime.two_le (q_prime n)
  have tt : Real.log (2) â‰¤ Real.log â†‘(q n) := by
    apply Real.log_le_log zero_lt_two
    exact t n

  trans  â†‘n * 2 * Real.log 2
  sorry
  ring_nf
  refine mul_le_mul ?_ (by rfl) zero_le_two (by positivity)
  refine mul_le_mul (by rfl) tt (by positivity) (Nat.cast_nonneg' n)

lemma mHyp'_tendsTo (m : N â†’ M) (q : N â†’ Q) (q_prime : âˆ€n, Nat.Prime (q n)) (m_hyp : mHyp' m q) : Filter.Tendsto m Filter.atTop Filter.atTop := sorry

theorem lemma_5_3       {n m q : â„•} [NeZero q] (q_prime : Nat.Prime q) (m_hyp : mHyp m n q)
  : â„™ (lemma_5_3_statementá¶œ : Set <| A_Matrix n m q) â‰¤ (q ^ (- n : â„)) := sorry


theorem lemma_5_3_also (q : N â†’ Q) [âˆ€n, NeZero (q n)]  (m : N â†’ M) (q_prime : âˆ€n, Nat.Prime (q n)) (m_hyp : mHyp' m q)
  (A : (n : N) â†’ (A_Matrix n (m n) (q n)))(hA : âˆ€n, lemma_5_3_statement (A n))
  (Ï‰ : (m : M) â†’ â„â‰¥0) (hÏ‰ : Ï‰_sqrt_log Ï‰)
  : âˆƒ (Îµ : (m : M) â†’ â„â‰¥0) (negl_Îµ : negligible Îµ) (Îµ_pos : âˆ€m, Îµ m â‰  0),
  âˆ€n : N, smoothing_parameter ((A n).Î›_ortho') (Îµ_pos (m n)) â‰¤ Ï‰ (m n) := by

  #check Lemma_2_6_then'
  #check A_Matrix.Î›_dual'
  have âŸ¨Îµ, negl_Îµ, Îµ_pos, soâŸ©:= Lemma_2_6_then' (fun n â†¦ (A n).Î›_ortho') (Ï‰ âˆ˜ m) ?_
  use Îµ, negl_Îµ, Îµ_pos
  intro n
  specialize so n
  specialize hA n
  unfold lemma_5_3_statement at hA
  nth_rw 2 [A_Matrix.Î›_dual] at so





  sorry
  have m_top := mHyp'_tendsTo _ _ q_prime m_hyp
  #check IsLittleO.comp_tendsto
  unfold Ï‰_sqrt_log at *
  #check IsBigO.trans_isLittleO
  have : (Ï‰) =O[Filter.atTop] (Ï‰ âˆ˜ m) := by sorry
  -- refine IsBigO.trans_isLittleO ?_ ?_

  sorry


-- hmm, in Corollary 5.4, "statistically close" describes what happens as n varies, but A is conditioned on n. this means statistically_close does not fit
-- what does it mean?

-- the distribution of the syndrome is statistically close to uniform
-- statistically close = statistical distance is negligible in n
-- blackboard: (A, Ax mod q) â‰ˆ (A, y)     f m â‰¥ ...
-- is it expressed that the distribution sampled from (A : Uniform,e : Gaussian) to (A, Ae mod q), is compared to the distribution (A : Uniform, y: Uniform),
--  and these distributions have type [ProbabilityMeasure ()]
#check let n :=5; let m := 7; let q := 10;
  ProbabilityMeasure ((A_Matrix n m q) Ã— (Fin n â†’ ZMod q))




-- example (q : â„• â†’ â„•) (m : â„• â†’ â„•)

-- this collection of subsets have all but 2q^-n values
def corollary_5_4_condition {q : N â†’ Q} [âˆ€n, NeZero (q n)] {m : N â†’ M} (subsets : (n : N) â†’ Set (A_Matrix n (m n) (q n)))
  := (âˆ€n, â„™ (subsets n) â‰¤ 2 * ((q n) ^ (- n : â„)))


def corollary_5_4_statement (q : N â†’ Q) [âˆ€n, NeZero (q n)]  (m : N â†’ M)
  (A : (n : N) â†’ A_Matrix n (m n) (q n)) (s : N â†’ â„â‰¥0) (s_pos : âˆ€n, s n â‰  0) :=
    statistically_close
      (fun n â†¦ (A n).syndrome_distributed (int_gaussian (m n) (s_pos n)))
      (fun n â†¦ uniform_over_Zqn n (q n))


theorem corollary_5_4 (q : N â†’ Q) [âˆ€n, NeZero (q n)]  (m : N â†’ M) (q_hyp : âˆ€n, Nat.Prime (q n)) (m_hyp : mHyp' m q)
  : âˆƒ(subsets : (n : N) â†’ Set (A_Matrix n (m n) (q n)))(_ : corollary_5_4_condition subsets),
  âˆ€(s : N â†’ â„â‰¥0)(_ : s =Ï‰[Filter.atTop] (sqrt_log âˆ˜ m))(s_pos : âˆ€n, s n â‰  0), -- â‰¥Ï‰ is the same as =Ï‰, right?
  âˆ€(A : (n : N) â†’ (A_Matrix n (m n) (q n)))(_ : âˆ€n, A n âˆˆ subsets n),
  corollary_5_4_statement q m A s s_pos
  := by


  sorry

-- should s be a function of m?

-- idea: have m be N â†’ M, to not confuse variables

-- unrelated idea: Module with polynomials as the scalars.
