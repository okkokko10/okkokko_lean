import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {b₁, . . . , bₙ} ⊂ ℝⁿ consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where ℝ is a field and ℝⁿ is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of ℝⁿ."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define ℝⁿ, B and Λ

-- btw, this is how a family v : ι → M is coerced into a basis:
#check Module.Basis.mk


variable {n : ℕ}
-- let's define an element of ℝⁿ as a function from the canonical type with n elements to ℝ
abbrev Rn := Fin n → ℝ
-- using abbrev makes it so lean automatically recognizes it as `Fin n → ℝ`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module ℝ (Fin n → ℝ) := Pi.Function.module (Fin n) ℝ ℝ
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module ℝ ℝ`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module ℝ ℝ := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector ℝ n) := by apply?
-- instance : Module ℝ (Vector ℝ n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul ℝ (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module ℝ (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module ℝ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n → Rn} (hli: LinearIndependent ℝ B)

-- oh yeah, I can just define Λ as the subgroup generated by B
def Λ {B : Fin n → Rn} {_ : LinearIndependent ℝ B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Λ.Bc : (Λ hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Λ := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Λ n B hli = @test.Λ n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Λ n B hli) := Λ.toAddCommGroup

-- instance : NormedAddCommGroup (@Λ n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : ℕ}
-- let's define an element of ℝⁿ as a function from the canonical type with n elements to ℝ
abbrev Rn := EuclideanSpace ℝ (Fin n)

instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module ℝ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) ℝ (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n → (@Rn n)} (hli: LinearIndependent ℝ B) : ⊤ ≤ Submodule.span ℝ (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Λ (B : Basis (Fin n) ℝ (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x ↦ B x

abbrev Zn := Fin n → ℤ

abbrev Zn' : Set (Fin n → ℝ) := Set.range ((Int.cast : ℤ → ℝ) ∘ ·)
-- abbrev Zn'' : Set (Fin n →₀ ℝ) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Zn₀ : Set (Fin n →₀ ℝ) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((↑) : ℤ → ℝ) ∘ ·)


lemma Λ.BZ : Λ B = B.repr.symm '' Zn₀ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine ⟨?_,?_⟩
  rw [Λ,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Λ B) := AddSubgroup.toAddCommGroup _

lemma Λ.B_in (i) : B i ∈ Λ B := by
  rw [Λ]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Λ.basis : Fin n → Λ B := fun i ↦ ⟨B i,Λ.B_in i⟩

-- maybe define Module ℤ (Λ B)

example : Basis (Fin n) ℤ (Λ B) := Basis.mk (R := ℤ) (v := Λ.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n → ℝ := q
example (q : Λ B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm ℝ := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x ↦ ℝ


def Λ.minimum_distance (norm : Rn → ℝ) := ⨅ (x ∈ (Λ B)) (_ : x ≠ 0), norm x

/-
paper:
The minimum distance λ1(Λ) of a lattice Λ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: λ1(Λ) = min06=x∈Λkxk. More generally, the ith successive
minimum λi(Λ) is the smallest radius r such that Λ contains i linearly independent vectors of norm at
most r. We write λ∞
1
to denote the minimum distance measured in the ∞ norm (which is defined as ‖x‖∞ = max |xᵢ|).
-/
-- i or more
def Λ.successive_minimum_distance (norm : (@Rn n) → ℝ) (i : ℕ)
  := ⨅ (r : ℝ) (_ : ∃s ⊆ ((Λ B).carrier), LinearIndependent ℝ (Subtype.val : s → Rn) ∧ s.encard ≤ i ∧ ∀x ∈ s, norm x ≤ r), r
-- note: for i := 0 this is ⊥ and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) ℝ (@Rn n)) := (Λ B) ⧸ (Λ B')
-- example (b : @Rn n) := Λ B ⧸ b
-- example (B' : Basis (Fin n) ℝ (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Λ B) := AddSubgroup.normal_of_comm (Λ B)

-- hmm, hold on, paper: "Therefore for lattices Λ' ⊆ Λ,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Λ, since they are also lattices? is that correct? VERIFY

example (Λ' : AddSubgroup (Λ B)) (a b : (Λ B) ⧸ Λ') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Λ' : AddSubgroup (Λ B)) (a : (Λ B) ⧸ Λ') (x) : x ∈ a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Λ or ℝⁿ?

-- is "a basis T of Λ" a `Basis (Fin n) ℤ (Λ B)`

-- def lemma_2_1 (S : Set (Λ B)) (h : ⊤ ≤ Submodule.span ℝ ((Subtype.val) '' S)) : Basis (Fin n) ℤ (Λ B) := sorry
