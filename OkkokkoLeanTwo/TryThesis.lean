import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {b‚ÇÅ, . . . , b‚Çô} ‚äÇ ‚Ñù‚Åø consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where ‚Ñù is a field and ‚Ñù‚Åø is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define ‚Ñù‚Åø, B and Œõ

-- btw, this is how a family v : Œπ ‚Üí M is coerced into a basis:
#check Module.Basis.mk


variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := Fin n ‚Üí ‚Ñù
-- using abbrev makes it so lean automatically recognizes it as `Fin n ‚Üí ‚Ñù`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module ‚Ñù (Fin n ‚Üí ‚Ñù) := Pi.Function.module (Fin n) ‚Ñù ‚Ñù
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module ‚Ñù ‚Ñù`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module ‚Ñù ‚Ñù := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector ‚Ñù n) := by apply?
-- instance : Module ‚Ñù (Vector ‚Ñù n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul ‚Ñù (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module ‚Ñù (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n ‚Üí Rn} (hli: LinearIndependent ‚Ñù B)

-- oh yeah, I can just define Œõ as the subgroup generated by B
def Œõ {B : Fin n ‚Üí Rn} {_ : LinearIndependent ‚Ñù B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Œõ.Bc : (Œõ hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Œõ := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Œõ n B hli = @test.Œõ n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Œõ n B hli) := Œõ.toAddCommGroup

-- instance : NormedAddCommGroup (@Œõ n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := EuclideanSpace ‚Ñù (Fin n)

#check ![1 , 2, (3 : ‚Ñ§)]
#check !‚ÇÇ[1 , 2, (3 : ‚Ñ§)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n ‚Üí ‚Ñù) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) ‚Ñù (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n ‚Üí (@Rn n)} (hli: LinearIndependent ‚Ñù B) : ‚ä§ ‚â§ Submodule.span ‚Ñù (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Œõ (B : Basis (Fin n) ‚Ñù (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x ‚Ü¶ B x

-- abbrev Zn := Fin n ‚Üí ‚Ñ§

abbrev Zn' : Set (Fin n ‚Üí ‚Ñù) := Set.range ((Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)
-- abbrev Zn'' : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Zn‚ÇÄ : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)


lemma Œõ.BZ : Œõ B = B.repr.symm '' Zn‚ÇÄ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine ‚ü®?_,?_‚ü©
  rw [Œõ,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Œõ B) := AddSubgroup.toAddCommGroup _

lemma Œõ.B_in (i) : B i ‚àà Œõ B := by
  rw [Œõ]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Œõ.basis : Fin n ‚Üí Œõ B := fun i ‚Ü¶ ‚ü®B i,Œõ.B_in i‚ü©

-- maybe define Module ‚Ñ§ (Œõ B)

example : Basis (Fin n) ‚Ñ§ (Œõ B) := Basis.mk (R := ‚Ñ§) (v := Œõ.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n ‚Üí ‚Ñù := q
example (q : Œõ B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm ‚Ñù := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x ‚Ü¶ ‚Ñù

open NNReal

def Œõ.minimum_distance (norm : Rn ‚Üí ‚Ñù‚â•0) := ‚®Ö (x ‚àà (Œõ B)) (_ : x ‚â† 0), norm x

/-
paper:
The minimum distance Œª1(Œõ) of a lattice Œõ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Œª1(Œõ) = min06=x‚ààŒõkxk. More generally, the ith successive
minimum Œªi(Œõ) is the smallest radius r such that Œõ contains i linearly independent vectors of norm at
most r. We write Œª‚àû
1
to denote the minimum distance measured in the ‚àû norm (which is defined as ‚Äñx‚Äñ‚àû = max |x·µ¢|).
-/
-- i or more
def Œõ.successive_minimum_distance (norm : (@Rn n) ‚Üí ‚Ñù‚â•0) (i : ‚Ñï)
  := ‚®Ö (r : ‚Ñù‚â•0) (_ : ‚àÉs ‚äÜ ((Œõ B).carrier), LinearIndependent ‚Ñù (Subtype.val : s ‚Üí Rn) ‚àß s.encard ‚â§ i ‚àß ‚àÄx ‚àà s, norm x ‚â§ r), r
-- note: for i := 0 this is ‚ä• and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) := (Œõ B) ‚ß∏ (Œõ B')
-- example (b : @Rn n) := Œõ B ‚ß∏ b
-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Œõ B) := AddSubgroup.normal_of_comm (Œõ B)

-- hmm, hold on, paper: "Therefore for lattices Œõ' ‚äÜ Œõ,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Œõ, since they are also lattices? is that correct? VERIFY

example (Œõ' : AddSubgroup (Œõ B)) (a b : (Œõ B) ‚ß∏ Œõ') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Œõ' : AddSubgroup (Œõ B)) (a : (Œõ B) ‚ß∏ Œõ') (x) : x ‚àà a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Œõ or ‚Ñù‚Åø?

-- is "a basis T of Œõ" a `Basis (Fin n) ‚Ñ§ (Œõ B)`

-- def lemma_2_1 (S : Set (Œõ B)) (h : ‚ä§ ‚â§ Submodule.span ‚Ñù ((Subtype.val) '' S)) : Basis (Fin n) ‚Ñ§ (Œõ B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Œõ has this?
    -- ùìõ is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - ‚åär‚åã * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n ‚Ñù) (v : n ‚Üí ‚Ñù) := A *·µ• v

-- variable {B' : Matrix}

-- let's revise Zn
#check Zn'
abbrev Zn (Œπ : Type*) : Set (Œπ ‚Üí ‚Ñù) := Set.range ((Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)
lemma Zn.mem_int {Œπ : Type*} {x} : (Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò x ‚àà Zn Œπ := ‚ü®x,rfl‚ü©
lemma Zn.mem_int' {Œπ : Type*} {x : Œπ ‚Üí ‚Ñ§} : (Int.cast <| x ¬∑) ‚àà Zn Œπ := ‚ü®x,rfl‚ü©

-- should I generalize further? there was ‚Ñ§‚Çê‚Åø

#check Pi.intCast_def

-- def Zn.general (Œπ : Type*) (R : Type*) [IntCast R] : Set (Œπ ‚Üí R) := Set.range ((Int.cast : ‚Ñ§ ‚Üí R) ‚àò ¬∑)


#check canLift
instance Zn.canLift {Œπ : Type*} : CanLift (Œπ ‚Üí ‚Ñù) (Œπ ‚Üí ‚Ñ§) (Int.cast <| ¬∑ ¬∑) fun f => f ‚àà Zn Œπ where
  prf := fun _ a ‚Ü¶ a

@[simp]
theorem Zn.add {Œπ : Type*} {x y} (hx : x ‚àà Zn Œπ) (hy : y ‚àà Zn Œπ) : (x + y) ‚àà Zn Œπ := by
  lift x to Œπ ‚Üí ‚Ñ§ using hx
  lift y to Œπ ‚Üí ‚Ñ§ using hy
  rw [Pi.add_def _ _]
  norm_cast
  exact Zn.mem_int'

#check PMF.bind_map


def ùìõ.ofMatrix {Œπ n} [Fintype n] (B : Matrix Œπ n ‚Ñù) := (B.mulVec : (n ‚Üí ‚Ñù) ‚Üí (Œπ ‚Üí ‚Ñù)) '' (Zn n)
--  (‚ü®B.mulVec,B.mulVec_add‚ü© : (n ‚Üí ‚Ñù) ‚Üí‚Çô+ (Œπ ‚Üí ‚Ñù))

-- theorem ùìõ.ofMatrix_def {Œπ n} [Fintype n] (B : Matrix Œπ n ‚Ñù) : ùìõ.ofMatrix B = (B.mulVec : (n ‚Üí ‚Ñù) ‚Üí (Œπ ‚Üí ‚Ñù)) '' (Zn n)

#check Matrix.mulVec_add

def ùìõ.ofMatrix' {Œπ n} [Fintype n] (B : Matrix Œπ n ‚Ñù) : AddSubgroup (Œπ ‚Üí ‚Ñù) where
  carrier := ùìõ.ofMatrix B
  add_mem'  := by
    unfold ofMatrix at *
    -- simp_all only [Set.mem_image]
    intro Bx By ‚ü®x,hx,hBx‚ü© ‚ü®y,hy,hBy‚ü©
    subst hBy hBx
    refine ‚ü®x + y,Zn.add hx hy,Matrix.mulVec_add _ _ _‚ü©
  zero_mem' := by
    refine ‚ü®0,‚ü®0,?_‚ü©,?_‚ü©
    simp only [Pi.comp_zero, Int.cast_zero, Function.const_zero]
    simp only [Matrix.mulVec_zero]

  neg_mem' := by
    intro Bx ‚ü®x,hx,hBx‚ü©
    subst hBx
    unfold ofMatrix
    simp only [Set.mem_image, Set.mem_range, exists_exists_eq_and]




    sorry

-- todo: note that the function from (Œπ ‚Üí ‚Ñ§) is a group homomorphism
#check AddHom
