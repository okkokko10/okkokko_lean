import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {b₁, . . . , bₙ} ⊂ ℝⁿ consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where ℝ is a field and ℝⁿ is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of ℝⁿ."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define ℝⁿ, B and Λ

-- btw, this is how a family v : ι → M is coerced into a basis:
#check Module.Basis.mk


variable {n : ℕ}
-- let's define an element of ℝⁿ as a function from the canonical type with n elements to ℝ
abbrev Rn := Fin n → ℝ
-- using abbrev makes it so lean automatically recognizes it as `Fin n → ℝ`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module ℝ (Fin n → ℝ) := Pi.Function.module (Fin n) ℝ ℝ
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module ℝ ℝ`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module ℝ ℝ := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector ℝ n) := by apply?
-- instance : Module ℝ (Vector ℝ n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul ℝ (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module ℝ (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module ℝ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n → Rn} (hli: LinearIndependent ℝ B)

-- oh yeah, I can just define Λ as the subgroup generated by B
def Λ {B : Fin n → Rn} {_ : LinearIndependent ℝ B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Λ.Bc : (Λ hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Λ := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Λ n B hli = @test.Λ n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Λ n B hli) := Λ.toAddCommGroup

-- instance : NormedAddCommGroup (@Λ n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : ℕ}
-- let's define an element of ℝⁿ as a function from the canonical type with n elements to ℝ
abbrev Rn := EuclideanSpace ℝ (Fin n)

instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module ℝ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) ℝ (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n → (@Rn n)} (hli: LinearIndependent ℝ B) : ⊤ ≤ Submodule.span ℝ (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Λ (B : Basis (Fin n) ℝ (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)

instance : AddCommGroup (Λ B) := AddSubgroup.toAddCommGroup _

-- coercions
example (q : @Rn n) : Fin n → ℝ := q
example (q : Λ B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm ℝ := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x ↦ ℝ


def Λ.minimum_distance (norm : Rn → ℝ) := ⨅ (x ∈ (Λ B)) (_ : x ≠ 0), norm x

/-
paper:
The minimum distance λ1(Λ) of a lattice Λ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: λ1(Λ) = min06=x∈Λkxk. More generally, the ith successive
minimum λi(Λ) is the smallest radius r such that Λ contains i linearly independent vectors of norm at
most r. We write λ∞
1
to denote the minimum distance measured in the ∞ norm (which is defined as ‖x‖∞ = max |xᵢ|).
-/

-- def Λ.successive_minimum_distance (i : ℕ) (norm : Rn → ℝ) := ⨅ (x ∈ (Λ B)) (_ : x ≠ 0), norm x
