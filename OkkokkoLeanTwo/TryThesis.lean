import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {b‚ÇÅ, . . . , b‚Çô} ‚äÇ ‚Ñù‚Åø consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where ‚Ñù is a field and ‚Ñù‚Åø is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define ‚Ñù‚Åø, B and Œõ

-- btw, this is how a family v : Œπ ‚Üí M is coerced into a basis:
#check Module.Basis.mk


variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := Fin n ‚Üí ‚Ñù
-- using abbrev makes it so lean automatically recognizes it as `Fin n ‚Üí ‚Ñù`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module ‚Ñù (Fin n ‚Üí ‚Ñù) := Pi.Function.module (Fin n) ‚Ñù ‚Ñù
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module ‚Ñù ‚Ñù`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module ‚Ñù ‚Ñù := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector ‚Ñù n) := by apply?
-- instance : Module ‚Ñù (Vector ‚Ñù n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul ‚Ñù (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module ‚Ñù (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n ‚Üí Rn} (hli: LinearIndependent ‚Ñù B)

-- oh yeah, I can just define Œõ as the subgroup generated by B
def Œõ {B : Fin n ‚Üí Rn} {_ : LinearIndependent ‚Ñù B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Œõ.Bc : (Œõ hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Œõ := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Œõ n B hli = @test.Œõ n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Œõ n B hli) := Œõ.toAddCommGroup

-- instance : NormedAddCommGroup (@Œõ n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := EuclideanSpace ‚Ñù (Fin n)

#check ![1 , 2, (3 : ‚Ñ§)]
#check !‚ÇÇ[1 , 2, (3 : ‚Ñ§)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n ‚Üí ‚Ñù) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) ‚Ñù (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n ‚Üí (@Rn n)} (hli: LinearIndependent ‚Ñù B) : ‚ä§ ‚â§ Submodule.span ‚Ñù (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Œõ (B : Basis (Fin n) ‚Ñù (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x ‚Ü¶ B x

-- abbrev Zn := Fin n ‚Üí ‚Ñ§

abbrev Zn' : Set (Fin n ‚Üí ‚Ñù) := Set.range ((Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)
-- abbrev Zn'' : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Zn‚ÇÄ : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)


lemma Œõ.BZ : Œõ B = B.repr.symm '' Zn‚ÇÄ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine ‚ü®?_,?_‚ü©
  rw [Œõ,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Œõ B) := AddSubgroup.toAddCommGroup _

lemma Œõ.B_in (i) : B i ‚àà Œõ B := by
  rw [Œõ]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Œõ.basis : Fin n ‚Üí Œõ B := fun i ‚Ü¶ ‚ü®B i,Œõ.B_in i‚ü©

-- maybe define Module ‚Ñ§ (Œõ B)

example : Basis (Fin n) ‚Ñ§ (Œõ B) := Basis.mk (R := ‚Ñ§) (v := Œõ.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n ‚Üí ‚Ñù := q
example (q : Œõ B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm ‚Ñù := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x ‚Ü¶ ‚Ñù

open NNReal

def Œõ.minimum_distance (norm : Rn ‚Üí ‚Ñù‚â•0) := ‚®Ö (x ‚àà (Œõ B)) (_ : x ‚â† 0), norm x

/-
paper:
The minimum distance Œª1(Œõ) of a lattice Œõ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Œª1(Œõ) = min06=x‚ààŒõkxk. More generally, the ith successive
minimum Œªi(Œõ) is the smallest radius r such that Œõ contains i linearly independent vectors of norm at
most r. We write Œª‚àû
1
to denote the minimum distance measured in the ‚àû norm (which is defined as ‚Äñx‚Äñ‚àû = max |x·µ¢|).
-/
-- i or more
def Œõ.successive_minimum_distance (norm : (@Rn n) ‚Üí ‚Ñù‚â•0) (i : ‚Ñï)
  := ‚®Ö (r : ‚Ñù‚â•0) (_ : ‚àÉs ‚äÜ ((Œõ B).carrier), LinearIndependent ‚Ñù (Subtype.val : s ‚Üí Rn) ‚àß s.encard ‚â§ i ‚àß ‚àÄx ‚àà s, norm x ‚â§ r), r
-- note: for i := 0 this is ‚ä• and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) := (Œõ B) ‚ß∏ (Œõ B')
-- example (b : @Rn n) := Œõ B ‚ß∏ b
-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Œõ B) := AddSubgroup.normal_of_comm (Œõ B)

-- hmm, hold on, paper: "Therefore for lattices Œõ' ‚äÜ Œõ,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Œõ, since they are also lattices? is that correct? VERIFY

example (Œõ' : AddSubgroup (Œõ B)) (a b : (Œõ B) ‚ß∏ Œõ') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Œõ' : AddSubgroup (Œõ B)) (a : (Œõ B) ‚ß∏ Œõ') (x) : x ‚àà a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Œõ or ‚Ñù‚Åø?

-- is "a basis T of Œõ" a `Basis (Fin n) ‚Ñ§ (Œõ B)`

-- def lemma_2_1 (S : Set (Œõ B)) (h : ‚ä§ ‚â§ Submodule.span ‚Ñù ((Subtype.val) '' S)) : Basis (Fin n) ‚Ñ§ (Œõ B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Œõ has this?
    -- ùìõ is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - ‚åär‚åã * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n ‚Ñù) (v : n ‚Üí ‚Ñù) := A *·µ• v

variable  {Œπ n : Type*} [Fintype n] (B : Matrix Œπ n ‚Ñù)
-- todo: should I assume [Fintype Œπ]? it's going to be true, and a lot relies on it

#check Pi.addMonoidHom
#check Pi.map

#check Pi.instAdd

instance Pi.instAddZero {Œπ : Type*} {M : Œπ ‚Üí Type*}  [(i : Œπ) ‚Üí AddZero (M i)] : AddZero (‚àÄ i, M i) := {}

def Pi_map_addMonoidHom {Œπ : Type*} {X Y : Œπ ‚Üí Type*}  [(i : Œπ) ‚Üí AddZero (X i)] [(i : Œπ) ‚Üí AddZero (Y i)] (c : (i : Œπ) ‚Üí X i ‚Üí+ Y i) : ((i : Œπ) ‚Üí X i) ‚Üí+ ((i : Œπ) ‚Üí Y i) where
  toFun := Pi.map (c ¬∑ ¬∑)
  map_zero' := by
    ext x : 1
    simp_all only [Pi.map_apply, Pi.zero_apply, map_zero]
  map_add' := by
    intro x y
    ext x_1 : 1
    simp_all only [Pi.map_apply, Pi.add_apply, map_add]


def int_cast : (Œπ ‚Üí ‚Ñ§) ‚Üí+ (Œπ ‚Üí ‚Ñù) := Pi_map_addMonoidHom fun _ ‚Ü¶ Int.castAddHom ‚Ñù

-- def int_cast : (Œπ ‚Üí ‚Ñ§) ‚Üí+ (Œπ ‚Üí ‚Ñù) where
--   toFun := (Int.cast <| ¬∑ ¬∑)
--   map_zero' := funext fun _ ‚Ü¶ Int.cast_zero
--   map_add' := fun x y ‚Ü¶ funext fun z ‚Ü¶ Int.cast_add (x z) (y z)

@[simp]
theorem int_cast.apply (f : Œπ ‚Üí ‚Ñ§) : int_cast f = (Int.cast <| f ¬∑) := rfl

@[simp high]
theorem int_cast.apply_single [DecidableEq Œπ] (i : Œπ) (x) : int_cast (Pi.single i x) = Pi.single i (Int.cast x) := by
  simp
  ext j
  simp only [Pi.single_apply, Int.cast_ite, Int.cast_zero]

example (a : ‚Ñ§ ‚Üí+ ‚Ñù) : ‚Ñ§ ‚Üí‚Çó[‚Ñ§] ‚Ñù := by exact a.toIntLinearMap
#check AddMonoidHom.toIntLinearMap

#check (1 : Matrix ‚Ñ§ ‚Ñ§ ‚Ñù)
-- def int_axes (Œπ : Type*) : Basis Œπ ‚Ñ§ (Œπ ‚Üí ‚Ñ§) where repr := LinearEquiv.refl
-- def int_axes (Œπ : Type*) [DecidableEq Œπ] := Set.range (1 : Matrix Œπ Œπ ‚Ñ§).col
def int_axes (Œπ : Type*) [Fintype Œπ] [DecidableEq Œπ] : Set (Œπ ‚Üí ‚Ñ§) := Set.range (Pi.single ¬∑ 1)

-- lemma int_axes.decomposition [Fintype Œπ] [DecidableEq Œπ] : int_axes Œπ

-- #check AddSubgroup.mem_closure_range_iff_of_fintype
theorem int_axes.basis [Fintype Œπ]  [DecidableEq Œπ] : AddSubgroup.closure (int_axes Œπ) = ‚ä§ := by
  ext x
  simp only [AddSubgroup.mem_top, iff_true]
  apply AddSubgroup.mem_closure_range_iff_of_fintype.mpr
  use x
  exact pi_eq_sum_univ' x


-- variable {B' : Matrix}

-- let's revise Zn

def Zn (Œπ : Type*) : AddSubgroup (Œπ ‚Üí ‚Ñù) := int_cast.range

def Zn.axes (Œπ : Type*) [Fintype Œπ] [DecidableEq Œπ] : Set (Œπ ‚Üí ‚Ñù) := int_cast '' (int_axes Œπ)

theorem Zn.axes_basis [Fintype Œπ] [DecidableEq Œπ] : AddSubgroup.closure (Zn.axes Œπ) = Zn Œπ := by
  unfold axes Zn
  rw [AddMonoidHom.range_eq_map,‚Üêint_axes.basis]
  exact Eq.symm (AddMonoidHom.map_closure int_cast (int_axes Œπ))


-- should I generalize further? there was ‚Ñ§‚Çê‚Åø

#check Pi.intCast_def

-- def Zn.general (Œπ : Type*) (R : Type*) [IntCast R] : Set (Œπ ‚Üí R) := Set.range ((Int.cast : ‚Ñ§ ‚Üí R) ‚àò ¬∑)





#check PMF.bind_map



def ùìõ.ofMatrix (B : Matrix Œπ n ‚Ñù) :=  (Zn n).map (B.mulVecLin : (n ‚Üí ‚Ñù) ‚Üí+ (Œπ ‚Üí ‚Ñù))


#check B.mulVecLin


theorem ùìõ.ofMatrix_def (B : Matrix Œπ n ‚Ñù)
  -- : ùìõ.ofMatrix B = (B.mulVec) '' (Set.range ((Int.cast <| ¬∑ ¬∑) : (_ ‚Üí _) ‚Üí _)) := rfl
  -- : ùìõ.ofMatrix B = Set.range (B.mulVec <| ((Int.cast <| ¬∑ ¬∑) : (_ ‚Üí _) ‚Üí _) ¬∑) := by
  : ùìõ.ofMatrix B = Set.range (fun x : _ ‚Üí _ ‚Ü¶ B.mulVec (Int.cast <| x ¬∑) ) := by
    sorry

theorem ùìõ.ofMatrix_def_comp (B : Matrix Œπ n ‚Ñù)
  : ùìõ.ofMatrix B = ( (B.mulVecLin.toAddMonoidHom).comp (int_cast) ).range := by
    sorry

theorem Zn.is_ofMatrix  [Fintype Œπ] [DecidableEq Œπ]  : Zn Œπ = ùìõ.ofMatrix (1 : Matrix Œπ Œπ _) := by
  ext x
  simp only [ùìõ.ofMatrix, Matrix.mulVecLin_one, AddSubgroup.mem_map, AddMonoidHom.coe_coe,
    LinearMap.id_coe, id_eq, exists_eq_right]




#check Matrix.mulVec_add

-- todo: note that the function from (Œπ ‚Üí ‚Ñ§) is a group homomorphism
#check AddMonoidHom

#check Matrix.mulVec.addMonoidHomLeft
#check Matrix.ext_addMonoidHom
-- #check Matrix.addMonoidHom
-- wait I'm an idiot, a matrix as a linear map is Matrix.mulVecLin, I found that already

lemma ùìõ.ofMatrix_is_closure (B : Matrix Œπ n ‚Ñù) : ofMatrix B = AddSubgroup.closure (Set.range B.col) := by
  symm
  apply AddSubgroup.closure_eq_of_le
  ¬∑
    simp [ofMatrix_def_comp]


    intro x ‚ü®xn,xcol‚ü©
    subst xcol
    simp only [Set.mem_range, Function.comp_apply, Matrix.mulVecBilin_apply]

    open scoped Classical in
    use Pi.single xn 1
    simp only [int_cast.apply_single, Int.cast_one, Matrix.mulVec_single, MulOpposite.op_one,
      one_smul]
  simp [ofMatrix]



  sorry

-- theorem ùìõ.ofMatrix_def {Œπ n} [Fintype n] (B : Matrix Œπ n ‚Ñù) : ùìõ.ofMatrix B = (B.mulVec : (n ‚Üí ‚Ñù) ‚Üí (Œπ ‚Üí ‚Ñù)) '' (Zn n)

#check Matrix.mulVec_add


-- todo: note that the function from (Œπ ‚Üí ‚Ñ§) is a group homomorphism
#check AddHom

#check Basis
#check Submodule
#check Submodule.traceDual
-- #check Submodule.traceDual
#check Algebra
-- #check Matrix.mulVec
example : Algebra ‚Ñ§ ‚Ñù := by exact Ring.toIntAlgebra ‚Ñù
#check IsScalarTower
#check Polynomial

#check dotProductEquiv
#check Dual -- not the same as dual lattice

open Function

-- def ùìõ.dualLattice {Œπ : Type*} [Fintype Œπ] (Œõ : Set (Œπ ‚Üí ‚Ñù)) := { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Œõ, dotProduct x v ‚àà Set.range (Int.cast)}
#check neg_involutive
#check Function.Involutive


#check AddSubgroup.map -- use to define ùìõ.ofMatrix

-- #check Real
#check Dual

-- theorem ùìõ.dualLattice_basis  {Œπ n : Type*} [Fintype Œπ] [Fintype n] (B : Matrix Œπ n ‚Ñù)
--   : ùìõ.dualLattice (ùìõ.ofMatrix B) = { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Set.range (B.col), dotProduct x v ‚àà Set.range (Int.cast)} := by
--   sorry

-- wait, sublattices are still n-dimensional? see Corollary 2.8
-- ah, I see. for example 2*Œõ is a sublattice of Œõ, but Œõ with a basis vector removed is not
-- no, nevermind. MG02 defines

#check HomogeneousSubmodule
#check HomogeneousIdeal
#check DirectSum
#check DirectSum.Decomposition
#check Algebra
#check Submodule.IsOrtho
#check Submodule.orthogonal
-- ^^^ would be a subset of a lattice, but it needs [RCLike ùïú]
#check Orthonormal
#check GradedRing

#check TopologicalSpace
def ùìõ.IsLattice (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) : Prop := sorry


def ùìõ.dualLattice_general {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù))  : AddSubgroup (Œπ ‚Üí ‚Ñù) where
  carrier := { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Œõ, x ‚¨ù·µ• v ‚àà S}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]



def ùìõ.dualLattice {Œπ : Type*} [Fintype Œπ] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) : AddSubgroup (Œπ ‚Üí ‚Ñù) := dualLattice_general (Int.castAddHom ‚Ñù |>.range) Œõ


#check Basis.addHaar


theorem ùìõ.dualLattice_involutive  {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) : Involutive (ùìõ.dualLattice_general (Œπ := Œπ) S) := by
  -- unfold Involutive
  intro Œõ

  -- let p (r : ‚Ñù) := (r ‚àà S)
  -- let h (v u : Œπ ‚Üí ‚Ñù) := p (v ‚¨ù·µ• u)


  set Œõ' := dualLattice_general S Œõ with back

  ext x
  rw [AddSubgroup.ext_iff] at back

  unfold dualLattice_general at back ‚ä¢
  change (‚àÄ v ‚àà Œõ', x ‚¨ù·µ• v ‚àà S) ‚Üî x ‚àà Œõ
  change ‚àÄv, v ‚àà Œõ' ‚Üî ‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S at back
  simp_rw [dotProduct_comm x _]
  refine ‚ü®?_,fun xL v vL' ‚Ü¶ (back v).mp vL' x xL‚ü©

  intro fo

  have : ‚àÄv, v ‚àà Œõ' ‚Üí ‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S := by exact fun v a x a_1 ‚Ü¶ a x a_1
  have t2: ‚àÄv, (‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S) ‚Üí v ‚àà Œõ' := by exact fun v a ‚Ü¶ this v (this v (this v (this v a)))

  --  `‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S` means the preimage of (v ‚¨ù·µ•) over S contains Œõ
  -- or that the image over Œõ is in S
  #check AddMonoidHom.range

  let qq (x : Œπ ‚Üí ‚Ñù) := (dotProductBilin ‚Ñ§ ‚Ñ§ x).toAddMonoidHom

  have nne (v : Œπ ‚Üí ‚Ñù): (‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S) ‚Üî Œõ.map (qq v) ‚â§ S := by
    simp [qq]
    constructor
    intro eer
    exact AddSubgroup.map_le_iff_le_comap.mpr (this v (this v (this v (this v eer))))
    intro xee x xL
    rw [AddSubgroup.map_le_iff_le_comap] at xee
    simp_all only [implies_true, Œõ']
    apply xee
    simp_all only
  simp_all only [implies_true]

  sorry

--

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Set (Œπ ‚Üí ‚Ñù))
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà AddSubgroup.closure (Œõ_basis), x ‚¨ù·µ• v ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà (Œõ_basis), x ‚¨ù·µ• v ‚àà S}
  := by
  ext x
  simp only [Set.mem_setOf_eq]

  sorry

-- try dual lattice as a comap

#check dotProductBilin
#check dotProductBilin_apply_apply
#check AddSubgroup.comap
#check dotProductBilin ‚Ñ§ ‚Ñ§

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (v : Œπ ‚Üí ‚Ñù)
  : {x | v ‚¨ù·µ• x ‚àà S} = (v ‚¨ù·µ• ¬∑) ‚Åª¬π' S
  := by rfl
example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (v : Œπ ‚Üí ‚Ñù)
  : {x | v ‚¨ù·µ• x ‚àà S} = (S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by rfl

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Set (Œπ ‚Üí ‚Ñù))
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà (Œõ_basis), v ‚¨ù·µ• x ‚àà S}
  = ‚®Ö v ‚àà Œõ_basis, (S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by
    ext x
    simp only [Set.mem_setOf_eq, Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]


example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Finset (Œπ ‚Üí ‚Ñù))
  : ‚®Ö v ‚àà Œõ_basis, ((S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)) : AddSubgroup (Œπ ‚Üí ‚Ñù)).carrier
  = (‚®Ö v ‚àà Œõ_basis, S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by
    ext x
    simp only [Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]
    constructor
    intro xw ew ‚ü®G,er‚ü©
    simp_all
    subst er
    simp only [Set.mem_iInter, SetLike.mem_coe]
    intro y eg
    sorry
    sorry

example [Fintype Œπ]  (S : AddSubgroup ‚Ñù)
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ z ‚àà (Zn n), ((B.mulVecLin : (n ‚Üí ‚Ñù) ‚Üí+ (Œπ ‚Üí ‚Ñù)) z) ‚¨ù·µ• x ‚àà S}
  := by
    unfold ùìõ.ofMatrix
    simp only [AddSubgroup.mem_map, AddMonoidHom.coe_coe, Matrix.mulVecBilin_apply,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ]


example [Fintype Œπ]  (S : AddSubgroup ‚Ñù)
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ z ‚àà (Zn n), dotProductBilin ‚Ñ§ ‚Ñ§ ((B.mulVecLin) z) x ‚àà S}
  := by
    calc
      {x | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S} = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := sorry
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := by rfl
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§).toAddMonoidHom.comp (B.mulVecLin)) z x ‚àà S} := sorry
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := sorry

-- right, if all the basis vectors dotprod to ‚Ñ§ then the matrix muls to ‚Ñ§‚Åø

open ProbabilityTheory
open MeasureTheory

#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianPDF


def gaussian [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) (x : Œπ ‚Üí ‚Ñù) := ProbabilityTheory.gaussianPDF 0 s ‚Äñx - c‚Äñ


#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.isGaussian_map

#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianReal _ _ |>.map

#check MeasureTheory.Measure.comap
#check MeasureTheory.Measure.comap_apply

-- we have a function Rn ‚Üí ‚Ñù, and a measure on ‚Ñù

example [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) : gaussian c s = ProbabilityTheory.gaussianPDF 0 s ‚àò (‚Äñ¬∑ - c‚Äñ) := by rfl

#check ProbabilityTheory.gaussianReal
#check MeasureTheory.Measure.withDensity
#check MeasureTheory.Measure.compProd_withDensity
-- look for theorems on this
#check MeasureTheory.pdf_def


#check MeasureTheory.withDensity_pdf_le_map

#check MeasureTheory.pdf

-- nope
example [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := (ProbabilityTheory.gaussianReal 0 s).comap (‚Äñ¬∑ - c‚Äñ) -- nope, not injective.

#check MeasureTheory.pdf



def gaussianMeasure [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := volume.withDensity (gaussianPDF 0 s ‚àò (‚Äñ¬∑ - c‚Äñ))
def gaussianMeasure' [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := gaussianMeasure c s |>.restrict Œõ

def gaussianMeasure'' [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù))  (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0)
  := (gaussianMeasure' Œõ c s Set.univ)‚Åª¬π ‚Ä¢ (gaussianMeasure' Œõ c s)


-- is this true?
-- example  [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) : IsGaussian (gaussianMeasure'' c s) := by sorry

#check IsGaussian.toIsProbabilityMeasure

#check IsGaussian.map_eq_gaussianReal



--oh, I found a lattice definition
#check IsZLattice
