import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {bâ‚, . . . , bâ‚™} âŠ‚ â„â¿ consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where â„ is a field and â„â¿ is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of â„â¿."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define â„â¿, B and Î›

-- btw, this is how a family v : Î¹ â†’ M is coerced into a basis:
#check Module.Basis.mk


variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := Fin n â†’ â„
-- using abbrev makes it so lean automatically recognizes it as `Fin n â†’ â„`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module â„ (Fin n â†’ â„) := Pi.Function.module (Fin n) â„ â„
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module â„ â„`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module â„ â„ := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector â„ n) := by apply?
-- instance : Module â„ (Vector â„ n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul â„ (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module â„ (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n â†’ Rn} (hli: LinearIndependent â„ B)

-- oh yeah, I can just define Î› as the subgroup generated by B
def Î› {B : Fin n â†’ Rn} {_ : LinearIndependent â„ B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Î›.Bc : (Î› hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Î› := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Î› n B hli = @test.Î› n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Î› n B hli) := Î›.toAddCommGroup

-- instance : NormedAddCommGroup (@Î› n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := EuclideanSpace â„ (Fin n)

#check ![1 , 2, (3 : â„¤)]
#check !â‚‚[1 , 2, (3 : â„¤)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n â†’ â„) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) â„ (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n â†’ (@Rn n)} (hli: LinearIndependent â„ B) : âŠ¤ â‰¤ Submodule.span â„ (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Î› (B : Basis (Fin n) â„ (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x â†¦ B x

-- abbrev Zn := Fin n â†’ â„¤

abbrev Zn' : Set (Fin n â†’ â„) := Set.range ((Int.cast : â„¤ â†’ â„) âˆ˜ Â·)
-- abbrev Zn'' : Set (Fin n â†’â‚€ â„) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Znâ‚€ : Set (Fin n â†’â‚€ â„) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((â†‘) : â„¤ â†’ â„) âˆ˜ Â·)


lemma Î›.BZ : Î› B = B.repr.symm '' Znâ‚€ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine âŸ¨?_,?_âŸ©
  rw [Î›,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Î› B) := AddSubgroup.toAddCommGroup _

lemma Î›.B_in (i) : B i âˆˆ Î› B := by
  rw [Î›]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Î›.basis : Fin n â†’ Î› B := fun i â†¦ âŸ¨B i,Î›.B_in iâŸ©

-- maybe define Module â„¤ (Î› B)

example : Basis (Fin n) â„¤ (Î› B) := Basis.mk (R := â„¤) (v := Î›.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n â†’ â„ := q
example (q : Î› B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm â„ := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x â†¦ â„

open NNReal

def Î›.minimum_distance (norm : Rn â†’ â„â‰¥0) := â¨… (x âˆˆ (Î› B)) (_ : x â‰  0), norm x

/-
paper:
The minimum distance Î»1(Î›) of a lattice Î› is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Î»1(Î›) = min06=xâˆˆÎ›kxk. More generally, the ith successive
minimum Î»i(Î›) is the smallest radius r such that Î› contains i linearly independent vectors of norm at
most r. We write Î»âˆ
1
to denote the minimum distance measured in the âˆ norm (which is defined as â€–xâ€–âˆ = max |xáµ¢|).
-/
-- i or more
def Î›.successive_minimum_distance (norm : (@Rn n) â†’ â„â‰¥0) (i : â„•)
  := â¨… (r : â„â‰¥0) (_ : âˆƒs âŠ† ((Î› B).carrier), LinearIndependent â„ (Subtype.val : s â†’ Rn) âˆ§ s.encard â‰¤ i âˆ§ âˆ€x âˆˆ s, norm x â‰¤ r), r
-- note: for i := 0 this is âŠ¥ and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) â„ (@Rn n)) := (Î› B) â§¸ (Î› B')
-- example (b : @Rn n) := Î› B â§¸ b
-- example (B' : Basis (Fin n) â„ (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Î› B) := AddSubgroup.normal_of_comm (Î› B)

-- hmm, hold on, paper: "Therefore for lattices Î›' âŠ† Î›,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Î›, since they are also lattices? is that correct? VERIFY

example (Î›' : AddSubgroup (Î› B)) (a b : (Î› B) â§¸ Î›') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Î›' : AddSubgroup (Î› B)) (a : (Î› B) â§¸ Î›') (x) : x âˆˆ a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Î› or â„â¿?

-- is "a basis T of Î›" a `Basis (Fin n) â„¤ (Î› B)`

-- def lemma_2_1 (S : Set (Î› B)) (h : âŠ¤ â‰¤ Submodule.span â„ ((Subtype.val) '' S)) : Basis (Fin n) â„¤ (Î› B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of â„â¿",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Î› has this?
    -- ğ“› is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - âŒŠrâŒ‹ * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n â„) (v : n â†’ â„) := A *áµ¥ v

variable  {Î¹ n : Type*} [Fintype n] (B : Matrix Î¹ n â„)
-- todo: should I assume [Fintype Î¹]? it's going to be true, and a lot relies on it

#check Pi.addMonoidHom
#check Pi.map

#check Pi.instAdd

instance Pi.instAddZero {Î¹ : Type*} {M : Î¹ â†’ Type*}  [(i : Î¹) â†’ AddZero (M i)] : AddZero (âˆ€ i, M i) := {}

def Pi_map_addMonoidHom {Î¹ : Type*} {X Y : Î¹ â†’ Type*}  [(i : Î¹) â†’ AddZero (X i)] [(i : Î¹) â†’ AddZero (Y i)] (c : (i : Î¹) â†’ X i â†’+ Y i) : ((i : Î¹) â†’ X i) â†’+ ((i : Î¹) â†’ Y i) where
  toFun := Pi.map (c Â· Â·)
  map_zero' := by
    ext x : 1
    simp_all only [Pi.map_apply, Pi.zero_apply, map_zero]
  map_add' := by
    intro x y
    ext x_1 : 1
    simp_all only [Pi.map_apply, Pi.add_apply, map_add]


def int_cast : (Î¹ â†’ â„¤) â†’+ (Î¹ â†’ â„) := Pi_map_addMonoidHom fun _ â†¦ Int.castAddHom â„

-- def int_cast : (Î¹ â†’ â„¤) â†’+ (Î¹ â†’ â„) where
--   toFun := (Int.cast <| Â· Â·)
--   map_zero' := funext fun _ â†¦ Int.cast_zero
--   map_add' := fun x y â†¦ funext fun z â†¦ Int.cast_add (x z) (y z)

@[simp]
theorem int_cast.apply (f : Î¹ â†’ â„¤) : int_cast f = (Int.cast <| f Â·) := rfl

@[simp high]
theorem int_cast.apply_single [DecidableEq Î¹] (i : Î¹) (x) : int_cast (Pi.single i x) = Pi.single i (Int.cast x) := by
  simp
  ext j
  simp only [Pi.single_apply, Int.cast_ite, Int.cast_zero]

example (a : â„¤ â†’+ â„) : â„¤ â†’â‚—[â„¤] â„ := by exact a.toIntLinearMap
#check AddMonoidHom.toIntLinearMap

#check (1 : Matrix â„¤ â„¤ â„)
-- def int_axes (Î¹ : Type*) : Basis Î¹ â„¤ (Î¹ â†’ â„¤) where repr := LinearEquiv.refl
-- def int_axes (Î¹ : Type*) [DecidableEq Î¹] := Set.range (1 : Matrix Î¹ Î¹ â„¤).col
def int_axes (Î¹ : Type*) [Fintype Î¹] [DecidableEq Î¹] : Set (Î¹ â†’ â„¤) := Set.range (Pi.single Â· 1)

-- lemma int_axes.decomposition [Fintype Î¹] [DecidableEq Î¹] : int_axes Î¹

-- #check AddSubgroup.mem_closure_range_iff_of_fintype
theorem int_axes.basis [Fintype Î¹]  [DecidableEq Î¹] : AddSubgroup.closure (int_axes Î¹) = âŠ¤ := by
  ext x
  simp only [AddSubgroup.mem_top, iff_true]
  apply AddSubgroup.mem_closure_range_iff_of_fintype.mpr
  use x
  exact pi_eq_sum_univ' x


-- variable {B' : Matrix}

-- let's revise Zn

def Zn (Î¹ : Type*) : AddSubgroup (Î¹ â†’ â„) := int_cast.range

def Zn.axes (Î¹ : Type*) [Fintype Î¹] [DecidableEq Î¹] : Set (Î¹ â†’ â„) := int_cast '' (int_axes Î¹)

theorem Zn.axes_basis [Fintype Î¹] [DecidableEq Î¹] : AddSubgroup.closure (Zn.axes Î¹) = Zn Î¹ := by
  unfold axes Zn
  rw [AddMonoidHom.range_eq_map,â†int_axes.basis]
  exact Eq.symm (AddMonoidHom.map_closure int_cast (int_axes Î¹))


-- should I generalize further? there was â„¤â‚â¿

#check Pi.intCast_def

-- def Zn.general (Î¹ : Type*) (R : Type*) [IntCast R] : Set (Î¹ â†’ R) := Set.range ((Int.cast : â„¤ â†’ R) âˆ˜ Â·)





#check PMF.bind_map



def ğ“›.ofMatrix (B : Matrix Î¹ n â„) :=  (Zn n).map (B.mulVecLin : (n â†’ â„) â†’+ (Î¹ â†’ â„))


#check B.mulVecLin


theorem ğ“›.ofMatrix_def (B : Matrix Î¹ n â„)
  -- : ğ“›.ofMatrix B = (B.mulVec) '' (Set.range ((Int.cast <| Â· Â·) : (_ â†’ _) â†’ _)) := rfl
  -- : ğ“›.ofMatrix B = Set.range (B.mulVec <| ((Int.cast <| Â· Â·) : (_ â†’ _) â†’ _) Â·) := by
  : ğ“›.ofMatrix B = Set.range (fun x : _ â†’ _ â†¦ B.mulVec (Int.cast <| x Â·) ) := by
    sorry

theorem ğ“›.ofMatrix_def_comp (B : Matrix Î¹ n â„)
  : ğ“›.ofMatrix B = ( (B.mulVecLin.toAddMonoidHom).comp (int_cast) ).range := by
    sorry

theorem Zn.is_ofMatrix  [Fintype Î¹] [DecidableEq Î¹]  : Zn Î¹ = ğ“›.ofMatrix (1 : Matrix Î¹ Î¹ _) := by
  ext x
  simp only [ğ“›.ofMatrix, Matrix.mulVecLin_one, AddSubgroup.mem_map, AddMonoidHom.coe_coe,
    LinearMap.id_coe, id_eq, exists_eq_right]




#check Matrix.mulVec_add

-- todo: note that the function from (Î¹ â†’ â„¤) is a group homomorphism
#check AddMonoidHom

#check Matrix.mulVec.addMonoidHomLeft
#check Matrix.ext_addMonoidHom
-- #check Matrix.addMonoidHom
-- wait I'm an idiot, a matrix as a linear map is Matrix.mulVecLin, I found that already

lemma ğ“›.ofMatrix_is_closure (B : Matrix Î¹ n â„) : ofMatrix B = AddSubgroup.closure (Set.range B.col) := by
  symm
  apply AddSubgroup.closure_eq_of_le
  Â·
    simp [ofMatrix_def_comp]


    intro x âŸ¨xn,xcolâŸ©
    subst xcol
    simp only [Set.mem_range, Function.comp_apply, Matrix.mulVecBilin_apply]

    open scoped Classical in
    use Pi.single xn 1
    simp only [int_cast.apply_single, Int.cast_one, Matrix.mulVec_single, MulOpposite.op_one,
      one_smul]
  simp [ofMatrix]



  sorry

-- theorem ğ“›.ofMatrix_def {Î¹ n} [Fintype n] (B : Matrix Î¹ n â„) : ğ“›.ofMatrix B = (B.mulVec : (n â†’ â„) â†’ (Î¹ â†’ â„)) '' (Zn n)

#check Matrix.mulVec_add


-- todo: note that the function from (Î¹ â†’ â„¤) is a group homomorphism
#check AddHom

#check Basis
#check Submodule
#check Submodule.traceDual
-- #check Submodule.traceDual
#check Algebra
-- #check Matrix.mulVec
example : Algebra â„¤ â„ := by exact Ring.toIntAlgebra â„
#check IsScalarTower
#check Polynomial

#check dotProductEquiv
#check Dual -- not the same as dual lattice

open Function

-- def ğ“›.dualLattice {Î¹ : Type*} [Fintype Î¹] (Î› : Set (Î¹ â†’ â„)) := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, dotProduct x v âˆˆ Set.range (Int.cast)}
#check neg_involutive
#check Function.Involutive


#check AddSubgroup.map -- use to define ğ“›.ofMatrix

-- #check Real
#check Dual

-- theorem ğ“›.dualLattice_basis  {Î¹ n : Type*} [Fintype Î¹] [Fintype n] (B : Matrix Î¹ n â„)
--   : ğ“›.dualLattice (ğ“›.ofMatrix B) = { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Set.range (B.col), dotProduct x v âˆˆ Set.range (Int.cast)} := by
--   sorry

-- wait, sublattices are still n-dimensional? see Corollary 2.8
-- ah, I see. for example 2*Î› is a sublattice of Î›, but Î› with a basis vector removed is not
-- no, nevermind. MG02 defines

#check HomogeneousSubmodule
#check HomogeneousIdeal
#check DirectSum
#check DirectSum.Decomposition
#check Algebra
#check Submodule.IsOrtho
#check Submodule.orthogonal
-- ^^^ would be a subset of a lattice, but it needs [RCLike ğ•œ]
#check Orthonormal
#check GradedRing

#check TopologicalSpace
def ğ“›.IsLattice (Î› : AddSubgroup (Î¹ â†’ â„)) : Prop := sorry


def ğ“›.dualLattice_general {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) (Î› : AddSubgroup (Î¹ â†’ â„))  : AddSubgroup (Î¹ â†’ â„) where
  carrier := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, x â¬áµ¥ v âˆˆ S}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]



def ğ“›.dualLattice {Î¹ : Type*} [Fintype Î¹] (Î› : AddSubgroup (Î¹ â†’ â„)) : AddSubgroup (Î¹ â†’ â„) := dualLattice_general (Int.castAddHom â„ |>.range) Î›


#check Basis.addHaar


theorem ğ“›.dualLattice_involutive  {Î¹ : Type*} [Fintype Î¹] (S : AddSubgroup â„) : Involutive (ğ“›.dualLattice_general (Î¹ := Î¹) S) := by
  -- unfold Involutive
  intro Î›

  -- let p (r : â„) := (r âˆˆ S)
  -- let h (v u : Î¹ â†’ â„) := p (v â¬áµ¥ u)


  set Î›' := dualLattice_general S Î› with back

  ext x
  rw [AddSubgroup.ext_iff] at back

  unfold dualLattice_general at back âŠ¢
  change (âˆ€ v âˆˆ Î›', x â¬áµ¥ v âˆˆ S) â†” x âˆˆ Î›
  change âˆ€v, v âˆˆ Î›' â†” âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S at back
  simp_rw [dotProduct_comm x _]
  refine âŸ¨?_,fun xL v vL' â†¦ (back v).mp vL' x xLâŸ©

  intro fo

  have : âˆ€v, v âˆˆ Î›' â†’ âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S := by exact fun v a x a_1 â†¦ a x a_1
  have t2: âˆ€v, (âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S) â†’ v âˆˆ Î›' := by exact fun v a â†¦ this v (this v (this v (this v a)))

  --  `âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S` means the preimage of (v â¬áµ¥) over S contains Î›
  -- or that the image over Î› is in S
  #check AddMonoidHom.range

  let qq (x : Î¹ â†’ â„) := (dotProductBilin â„¤ â„¤ x).toAddMonoidHom

  have nne (v : Î¹ â†’ â„): (âˆ€ x âˆˆ Î›, v â¬áµ¥ x âˆˆ S) â†” Î›.map (qq v) â‰¤ S := by
    simp [qq]
    constructor
    intro eer
    exact AddSubgroup.map_le_iff_le_comap.mpr (this v (this v (this v (this v eer))))
    intro xee x xL
    rw [AddSubgroup.map_le_iff_le_comap] at xee
    simp_all only [implies_true, Î›']
    apply xee
    simp_all only
  simp_all only [implies_true]

  sorry
