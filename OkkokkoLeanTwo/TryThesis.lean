import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {bâ‚, . . . , bâ‚™} âŠ‚ â„â¿ consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where â„ is a field and â„â¿ is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of â„â¿."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define â„â¿, B and Î›

-- btw, this is how a family v : Î¹ â†’ M is coerced into a basis:
#check Module.Basis.mk


variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := Fin n â†’ â„
-- using abbrev makes it so lean automatically recognizes it as `Fin n â†’ â„`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module â„ (Fin n â†’ â„) := Pi.Function.module (Fin n) â„ â„
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module â„ â„`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module â„ â„ := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector â„ n) := by apply?
-- instance : Module â„ (Vector â„ n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul â„ (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module â„ (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n â†’ Rn} (hli: LinearIndependent â„ B)

-- oh yeah, I can just define Î› as the subgroup generated by B
def Î› {B : Fin n â†’ Rn} {_ : LinearIndependent â„ B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Î›.Bc : (Î› hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Î› := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Î› n B hli = @test.Î› n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Î› n B hli) := Î›.toAddCommGroup

-- instance : NormedAddCommGroup (@Î› n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1


open Module

variable {n : â„•}
-- let's define an element of â„â¿ as a function from the canonical type with n elements to â„
abbrev Rn := EuclideanSpace â„ (Fin n)

#check ![1 , 2, (3 : â„¤)]
#check !â‚‚[1 , 2, (3 : â„¤)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n â†’ â„) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module â„ (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) â„ (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n â†’ (@Rn n)} (hli: LinearIndependent â„ B) : âŠ¤ â‰¤ Submodule.span â„ (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Î› (B : Basis (Fin n) â„ (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x â†¦ B x

-- abbrev Zn := Fin n â†’ â„¤

abbrev Zn' : Set (Fin n â†’ â„) := Set.range ((Int.cast : â„¤ â†’ â„) âˆ˜ Â·)
-- abbrev Zn'' : Set (Fin n â†’â‚€ â„) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Znâ‚€ : Set (Fin n â†’â‚€ â„) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((â†‘) : â„¤ â†’ â„) âˆ˜ Â·)


lemma Î›.BZ : Î› B = B.repr.symm '' Znâ‚€ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine âŸ¨?_,?_âŸ©
  rw [Î›,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Î› B) := AddSubgroup.toAddCommGroup _

lemma Î›.B_in (i) : B i âˆˆ Î› B := by
  rw [Î›]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Î›.basis : Fin n â†’ Î› B := fun i â†¦ âŸ¨B i,Î›.B_in iâŸ©

-- maybe define Module â„¤ (Î› B)

example : Basis (Fin n) â„¤ (Î› B) := Basis.mk (R := â„¤) (v := Î›.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n â†’ â„ := q
example (q : Î› B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm â„ := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x â†¦ â„

open NNReal

def Î›.minimum_distance (norm : Rn â†’ â„â‰¥0) := â¨… (x âˆˆ (Î› B)) (_ : x â‰  0), norm x

/-
paper:
The minimum distance Î»1(Î›) of a lattice Î› is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Î»1(Î›) = min06=xâˆˆÎ›kxk. More generally, the ith successive
minimum Î»i(Î›) is the smallest radius r such that Î› contains i linearly independent vectors of norm at
most r. We write Î»âˆ
1
to denote the minimum distance measured in the âˆ norm (which is defined as â€–xâ€–âˆ = max |xáµ¢|).
-/
-- i or more
def Î›.successive_minimum_distance (norm : (@Rn n) â†’ â„â‰¥0) (i : â„•)
  := â¨… (r : â„â‰¥0) (_ : âˆƒs âŠ† ((Î› B).carrier), LinearIndependent â„ (Subtype.val : s â†’ Rn) âˆ§ s.encard â‰¤ i âˆ§ âˆ€x âˆˆ s, norm x â‰¤ r), r
-- note: for i := 0 this is âŠ¥ and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) â„ (@Rn n)) := (Î› B) â§¸ (Î› B')
-- example (b : @Rn n) := Î› B â§¸ b
-- example (B' : Basis (Fin n) â„ (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Î› B) := AddSubgroup.normal_of_comm (Î› B)

-- hmm, hold on, paper: "Therefore for lattices Î›' âŠ† Î›,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Î›, since they are also lattices? is that correct? VERIFY

example (Î›' : AddSubgroup (Î› B)) (a b : (Î› B) â§¸ Î›') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Î›' : AddSubgroup (Î› B)) (a : (Î› B) â§¸ Î›') (x) : x âˆˆ a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Î› or â„â¿?

-- is "a basis T of Î›" a `Basis (Fin n) â„¤ (Î› B)`

-- def lemma_2_1 (S : Set (Î› B)) (h : âŠ¤ â‰¤ Submodule.span â„ ((Subtype.val) '' S)) : Basis (Fin n) â„¤ (Î› B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of â„â¿",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Î› has this?
    -- ğ“› is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - âŒŠrâŒ‹ * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n â„) (v : n â†’ â„) := A *áµ¥ v

-- variable {B' : Matrix}

-- let's revise Zn
#check Zn'
abbrev Zn (Î¹ : Type*) : Set (Î¹ â†’ â„) := Set.range ((Int.cast : â„¤ â†’ â„) âˆ˜ Â·)
lemma Zn.mem_int {Î¹ : Type*} {x} : (Int.cast : â„¤ â†’ â„) âˆ˜ x âˆˆ Zn Î¹ := âŸ¨x,rflâŸ©
lemma Zn.mem_int' {Î¹ : Type*} {x : Î¹ â†’ â„¤} : (Int.cast <| x Â·) âˆˆ Zn Î¹ := âŸ¨x,rflâŸ©

-- should I generalize further? there was â„¤â‚â¿

#check Pi.intCast_def

-- def Zn.general (Î¹ : Type*) (R : Type*) [IntCast R] : Set (Î¹ â†’ R) := Set.range ((Int.cast : â„¤ â†’ R) âˆ˜ Â·)


#check canLift
instance Zn.canLift {Î¹ : Type*} : CanLift (Î¹ â†’ â„) (Î¹ â†’ â„¤) (Int.cast <| Â· Â·) fun f => f âˆˆ Zn Î¹ where
  prf := fun _ a â†¦ a

@[simp]
theorem Zn.add {Î¹ : Type*} {x y} (hx : x âˆˆ Zn Î¹) (hy : y âˆˆ Zn Î¹) : (x + y) âˆˆ Zn Î¹ := by
  lift x to Î¹ â†’ â„¤ using hx
  lift y to Î¹ â†’ â„¤ using hy
  rw [Pi.add_def _ _]
  norm_cast
  exact Zn.mem_int'

#check PMF.bind_map


def ğ“›.ofMatrix {Î¹ n} [Fintype n] (B : Matrix Î¹ n â„) := (B.mulVec : (n â†’ â„) â†’ (Î¹ â†’ â„)) '' (Zn n)
--  (âŸ¨B.mulVec,B.mulVec_addâŸ© : (n â†’ â„) â†’â‚™+ (Î¹ â†’ â„))

-- theorem ğ“›.ofMatrix_def {Î¹ n} [Fintype n] (B : Matrix Î¹ n â„) : ğ“›.ofMatrix B = (B.mulVec : (n â†’ â„) â†’ (Î¹ â†’ â„)) '' (Zn n)

#check Matrix.mulVec_add

def ğ“›.ofMatrix' {Î¹ n} [Fintype n] (B : Matrix Î¹ n â„) : AddSubgroup (Î¹ â†’ â„) where
  carrier := ğ“›.ofMatrix B
  add_mem'  := by
    unfold ofMatrix at *
    -- simp_all only [Set.mem_image]
    intro Bx By âŸ¨x,hx,hBxâŸ© âŸ¨y,hy,hByâŸ©
    subst hBy hBx
    refine âŸ¨x + y,Zn.add hx hy,Matrix.mulVec_add _ _ _âŸ©
  zero_mem' := by
    refine âŸ¨0,âŸ¨0,?_âŸ©,?_âŸ©
    simp only [Pi.comp_zero, Int.cast_zero, Function.const_zero]
    simp only [Matrix.mulVec_zero]

  neg_mem' := by
    intro Bx âŸ¨x,hx,hBxâŸ©
    subst hBx
    unfold ofMatrix
    simp only [Set.mem_image, Set.mem_range, exists_exists_eq_and]




    sorry

-- todo: note that the function from (Î¹ â†’ â„¤) is a group homomorphism
#check AddHom

#check Basis
#check Submodule
#check Submodule.traceDual
-- #check Submodule.traceDual
#check Algebra
-- #check Matrix.mulVec
example : Algebra â„¤ â„ := by exact Ring.toIntAlgebra â„
#check IsScalarTower
#check Polynomial

#check dotProductEquiv
#check Dual -- not the same as dual lattice

open Function

def ğ“›.dualLattice {Î¹ : Type*} [Fintype Î¹] (Î› : Set (Î¹ â†’ â„)) := { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Î›, dotProduct x v âˆˆ Set.range (Int.cast)}
#check neg_involutive
#check Function.Involutive

theorem ğ“›.dualLattice_involutive  {Î¹ : Type*} [Fintype Î¹] : Involutive (ğ“›.dualLattice (Î¹ := Î¹)) := by
  -- unfold Involutive
  intro Î›

  let p (r : â„) := (r âˆˆ Set.range Int.cast)
  let h (v u : Î¹ â†’ â„) := p (v â¬áµ¥ u)


  have uu Î› : dualLattice Î› = {x | âˆ€ v âˆˆ Î›, h x v} := rfl

  set Î›' := dualLattice Î› with back

  -- ext x



  -- unfold dualLattice at back âŠ¢

  change {x | âˆ€ y âˆˆ Î›', h x y} = Î›
  change {y | âˆ€ x âˆˆ Î›, h y x} = Î›' at back
  convert_to {y | âˆ€ x âˆˆ Î›, h x y} = Î›' using 5 at back
  Â· unfold h
    congr! 1
    exact dotProduct_comm _ _






  -- rw [Set.ext_iff] at back âŠ¢
  -- simp only [Set.mem_setOf_eq] at *

  -- intro x
  -- constructor
  -- intro hy
  -- have rr t := (back t).mpr

  rw [â†back]
  simp only [Set.mem_setOf_eq]
  clear * -
  ext x
  simp only [Set.mem_setOf_eq]
  refine âŸ¨?_,fun a _ a_1 â†¦ a_1 x aâŸ©
  intro hh
  -- strange... there must be an assumption I'm missing.
  -- maybe bacause it's not a lattice, but an arbitrary set
  sorry


theorem ğ“›.dualLattice_basis  {Î¹ n : Type*} [Fintype Î¹] [Fintype n] (B : Matrix Î¹ n â„)
  : ğ“›.dualLattice (ğ“›.ofMatrix B) = { x : Î¹ â†’ â„ | âˆ€ v âˆˆ Set.range (B.col), dotProduct x v âˆˆ Set.range (Int.cast)} := by sorry
