import Mathlib


noncomputable section
namespace s1

-- paper: "Let B = {b‚ÇÅ, . . . , b‚Çô} ‚äÇ ‚Ñù‚Åø consist of n linearly independent vectors."
-- let's see. Mathlib has a definition of Linear Independence:
#reduce LinearIndependent
-- it states that linear combinations of the family v are unique.
-- "A module is a generalization of vector spaces to a scalar semiring."
#check Module
-- in our case, where ‚Ñù is a field and ‚Ñù‚Åø is an additive group, there is no difference to a vector.
-- paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø."
--   (wait, what does "discrete" mean?)
-- yes, this is expressable in Lean.
#check AddSubgroup

-- let's define ‚Ñù‚Åø, B and Œõ

-- btw, this is how a family v : Œπ ‚Üí M is coerced into a basis:
#check Module.Basis.mk


variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := Fin n ‚Üí ‚Ñù
-- using abbrev makes it so lean automatically recognizes it as `Fin n ‚Üí ‚Ñù`

-- let's show that Rn is a vector space

-- define the additive group of Rn the usual way for functions into an additive group
set_option trace.Meta.synthInstance true in
instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := Pi.addCommGroup
-- we are required to use `(@Rn n)` instead of just `Rn` for reasons
-- -- btw, Pi.addCommGroup can actually even handle functions whose output type depends on the input:
-- #check Pi.addCommGroup

set_option trace.Meta.synthInstance true in -- displays the implicit instances
noncomputable example : Module ‚Ñù (Fin n ‚Üí ‚Ñù) := Pi.Function.module (Fin n) ‚Ñù ‚Ñù
-- hm? that requires a noncomputable? "depends on `Real.instRCLike`"
-- huh? it uses vvv to instantiate `Module ‚Ñù ‚Ñù`?
#check RCLike.toInnerProductSpaceReal.toModule
#check Real.instRCLike
-- nevermind this, it's not directly compatible with the earlier.
-- noncomputable example : Module ‚Ñù ‚Ñù := inferInstance

-- what did the `AddCommGroup (@Rn n)` use?

-- uh, anyway

-- example (i : Fin n) (x y : Rn) : (x + y) i = x i + y i := by rfl

#check Vector.instAddCommGroup

-- instance : DistribMulAction
-- instance : AddCommMonoid (Vector ‚Ñù n) := by apply?
-- instance : Module ‚Ñù (Vector ‚Ñù n) := inferInstance

set_option trace.Meta.synthInstance true in
example : SMul ‚Ñù (@Rn n) := Function.hasSMul

-- set_option trace.Meta.synthInstance true in
-- example : @Module ‚Ñù (@Rn n) _ (Rn.instAddCommGroup.toAddCommMonoid) where
--   add_smul := sorry
--   zero_smul := sorry

-- wait, there's some issues

set_option trace.Meta.synthInstance true in
instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

-- I hope that works

variable {B : Fin n ‚Üí Rn} (hli: LinearIndependent ‚Ñù B)

-- oh yeah, I can just define Œõ as the subgroup generated by B
def Œõ {B : Fin n ‚Üí Rn} {_ : LinearIndependent ‚Ñù B} := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)
-- lemma Œõ.Bc : (Œõ hli) = sorry := sorry
-- hm, defining it as the set of Bc?

-- just checking
def test.Œõ := @AddSubgroup.closure (@Rn n) _ (Set.range B)
example : @Œõ n B hli = @test.Œõ n B := rfl

-- vvv is this good practise? I don't recall
instance : AddCommGroup (@Œõ n B hli) := Œõ.toAddCommGroup

-- instance : NormedAddCommGroup (@Œõ n B hli) :=

-- hm, should I      (should I what? what was I going to say?)

-- wait
#check EuclideanSpace
-- I should use this.

end s1
namespace s2

open Module

variable {n : ‚Ñï}
-- let's define an element of ‚Ñù‚Åø as a function from the canonical type with n elements to ‚Ñù
abbrev Rn := EuclideanSpace ‚Ñù (Fin n)

#check ![1 , 2, (3 : ‚Ñ§)]
#check !‚ÇÇ[1 , 2, (3 : ‚Ñ§)]
#check !![1 , 2, 3; 4, 5, 6]

-- example : LinearEquiv (@Rn n) (Fin n ‚Üí ‚Ñù) := by sorry


instance Rn.instAddCommGroup : AddCommGroup (@Rn n) := inferInstance
instance Rn.instAddCommMonoid : AddCommGroup (@Rn n) := instAddCommGroup

instance Rn.instModule : @Module ‚Ñù (@Rn n) Real.instRing.toSemiring (Rn.instAddCommGroup.toAddCommMonoid) := inferInstance

variable {B : Basis (Fin n) ‚Ñù (@Rn n)}

-- wait, where's the theorem that n linearly independent vectors are a basis?

example {B : Fin n ‚Üí (@Rn n)} (hli: LinearIndependent ‚Ñù B) : ‚ä§ ‚â§ Submodule.span ‚Ñù (Set.range B) := sorry

-- example := Module.Basis.mk hli _


def Œõ (B : Basis (Fin n) ‚Ñù (@Rn n))
  : AddSubgroup (@Rn n)
  := @AddSubgroup.closure (@Rn n) (Rn.instAddCommGroup.toAddGroup) (Set.range B)


#check fun x ‚Ü¶ B x

-- abbrev Zn := Fin n ‚Üí ‚Ñ§

abbrev Zn' : Set (Fin n ‚Üí ‚Ñù) := Set.range ((Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)
-- abbrev Zn'' : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Finsupp.equivFunOnFinite.symm '' Zn'
abbrev Zn‚ÇÄ : Set (Fin n ‚Üí‚ÇÄ ‚Ñù) := Set.range ( Finsupp.equivFunOnFinite.symm <| ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑)


lemma Œõ.BZ : Œõ B = B.repr.symm '' Zn‚ÇÄ := by
  ext x

  simp only [SetLike.mem_coe, Basis.repr_symm_apply, Set.mem_image, Set.mem_range,
    exists_exists_eq_and]
  refine ‚ü®?_,?_‚ü©
  rw [Œõ,AddSubgroup.mem_closure]
  intro xin

  sorry
  sorry

instance : AddCommGroup (Œõ B) := AddSubgroup.toAddCommGroup _

lemma Œõ.B_in (i) : B i ‚àà Œõ B := by
  rw [Œõ]
  apply AddSubgroup.mem_closure_of_mem -- aesop
  simp_all only [Set.mem_range, exists_apply_eq_apply]

variable (B) in
def Œõ.basis : Fin n ‚Üí Œõ B := fun i ‚Ü¶ ‚ü®B i,Œõ.B_in i‚ü©

-- maybe define Module ‚Ñ§ (Œõ B)

example : Basis (Fin n) ‚Ñ§ (Œõ B) := Basis.mk (R := ‚Ñ§) (v := Œõ.basis B) sorry sorry


-- coercions
example (q : @Rn n) : Fin n ‚Üí ‚Ñù := q
example (q : Œõ B) : (@Rn n) := by
  #check q
  exact q.val

example : Norm ‚Ñù := by exact Real.norm

example : Norm (@Rn n) := by exact PiLp.instNorm 2 fun x ‚Ü¶ ‚Ñù

open NNReal

def Œõ.minimum_distance (norm : Rn ‚Üí ‚Ñù‚â•0) := ‚®Ö (x ‚àà (Œõ B)) (_ : x ‚â† 0), norm x

/-
paper:
The minimum distance Œª1(Œõ) of a lattice Œõ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Œª1(Œõ) = min06=x‚ààŒõkxk. More generally, the ith successive
minimum Œªi(Œõ) is the smallest radius r such that Œõ contains i linearly independent vectors of norm at
most r. We write Œª‚àû
1
to denote the minimum distance measured in the ‚àû norm (which is defined as ‚Äñx‚Äñ‚àû = max |x·µ¢|).
-/
-- i or more
def Œõ.successive_minimum_distance (norm : (@Rn n) ‚Üí ‚Ñù‚â•0) (i : ‚Ñï)
  := ‚®Ö (r : ‚Ñù‚â•0) (_ : ‚àÉs ‚äÜ ((Œõ B).carrier), LinearIndependent ‚Ñù (Subtype.val : s ‚Üí Rn) ‚àß s.encard ‚â§ i ‚àß ‚àÄx ‚àà s, norm x ‚â§ r), r
-- note: for i := 0 this is ‚ä• and i := 1 this is 0

-- quotient groups

-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) := (Œõ B) ‚ß∏ (Œõ B')
-- example (b : @Rn n) := Œõ B ‚ß∏ b
-- example (B' : Basis (Fin n) ‚Ñù (@Rn n)) :=
#check QuotientAddGroup.coe_mk'


instance : AddSubgroup.Normal (Œõ B) := AddSubgroup.normal_of_comm (Œõ B)

-- hmm, hold on, paper: "Therefore for lattices Œõ' ‚äÜ Œõ,..."
-- sub-lattices? Oh, these aren't full-rank lattices. confusing
-- wait, we can just use subgroups of Œõ, since they are also lattices? is that correct? VERIFY

example (Œõ' : AddSubgroup (Œõ B)) (a b : (Œõ B) ‚ß∏ Œõ') : a + b = b + a := by
  exact AddCommMagma.add_comm a b

-- example (Œõ' : AddSubgroup (Œõ B)) (a : (Œõ B) ‚ß∏ Œõ') (x) : x ‚àà a := sorry


-- what does "full-rank set of lattice vectors" mean?
-- I assume a set whose span is the whole space
-- wait, hold on, what is "the whole space"? Œõ or ‚Ñù‚Åø?

-- is "a basis T of Œõ" a `Basis (Fin n) ‚Ñ§ (Œõ B)`

-- def lemma_2_1 (S : Set (Œõ B)) (h : ‚ä§ ‚â§ Submodule.span ‚Ñù ((Subtype.val) '' S)) : Basis (Fin n) ‚Ñ§ (Œõ B) := sorry

#check Basis.addHaar

-- 1. [https://en.wikipedia.org/wiki/Lattice_(group)]
-- 2. [https://en.wikipedia.org/wiki/Lattice_(module)]
-- 3. [https://en.wikipedia.org/wiki/Lattice_(discrete_subgroup)]
-- I must study to find the best formalism.
--
-- about paper: "A lattice is a discrete additive subgroup of ‚Ñù‚Åø",
-- "Lattice (discrete subgroup)" links [https://en.wikipedia.org/wiki/Discrete_group], which is [https://en.wikipedia.org/wiki/Topological_group]
#check IsTopologicalAddGroup
#check DiscreteTopology -- Œõ has this?
    -- ùìõ is written \MCL
-- (forgot what I was going to note)
-- "Lattice (group)" states "Every point in the space is within some maximum distance of a lattice point.". this definition means it is full-rank
#check Basis

-- what can be a "discrete additive subgroup"? is that definition enough?
/-
relaxing that it's generated by a basis, or linearly independent vectors
does discreteness imply linear independence? - no.
if v u are linearly dependent, u = r * v where r is real
is the finitely generated (v, r*v) non-discrete?
it's equal to (1,r) * v
it's as discrete as (1,r)
(1, r)
can you find a linear combination of 1 and r that is arbitrarily close to some point?
    take a rational approximation a/b of r.
    1 * a - r * b = a - r * b
  assume 0 < r < 1 (using r := r - ‚åär‚åã * 1)
    a => 1-a
    take the smaller one, unless a = 1/2
  if r = a/b is rational, then x * 1 + y * a/b = (x * b + y * a)/b which can only be as small as 1/b, so it's discrete
-- ah, obviously, it's discrete iff there's only finite elements in [0,1]

-/
#check Set.matrix

#check Matrix.mul_apply

open scoped Matrix

example {m n} [Fintype n] (A : Matrix m n ‚Ñù) (v : n ‚Üí ‚Ñù) := A *·µ• v

variable  {Œπ n : Type*} [Fintype n] (B : Matrix Œπ n ‚Ñù)
-- todo: should I assume [Fintype Œπ]? it's going to be true, and a lot relies on it

#check Pi.addMonoidHom
#check Pi.map

#check Pi.instAdd

instance Pi.instAddZero {Œπ : Type*} {M : Œπ ‚Üí Type*}  [(i : Œπ) ‚Üí AddZero (M i)] : AddZero (‚àÄ i, M i) := {}

def Pi_map_addMonoidHom {Œπ : Type*} {X Y : Œπ ‚Üí Type*}  [(i : Œπ) ‚Üí AddZero (X i)] [(i : Œπ) ‚Üí AddZero (Y i)] (c : (i : Œπ) ‚Üí X i ‚Üí+ Y i) : ((i : Œπ) ‚Üí X i) ‚Üí+ ((i : Œπ) ‚Üí Y i) where
  toFun := Pi.map (c ¬∑ ¬∑)
  map_zero' := by
    ext x : 1
    simp_all only [Pi.map_apply, Pi.zero_apply, map_zero]
  map_add' := by
    intro x y
    ext x_1 : 1
    simp_all only [Pi.map_apply, Pi.add_apply, map_add]


def int_cast : (Œπ ‚Üí ‚Ñ§) ‚Üí+ (Œπ ‚Üí ‚Ñù) := Pi_map_addMonoidHom fun _ ‚Ü¶ Int.castAddHom ‚Ñù

-- def int_cast : (Œπ ‚Üí ‚Ñ§) ‚Üí+ (Œπ ‚Üí ‚Ñù) where
--   toFun := (Int.cast <| ¬∑ ¬∑)
--   map_zero' := funext fun _ ‚Ü¶ Int.cast_zero
--   map_add' := fun x y ‚Ü¶ funext fun z ‚Ü¶ Int.cast_add (x z) (y z)

@[simp]
theorem int_cast.apply (f : Œπ ‚Üí ‚Ñ§) : int_cast f = (Int.cast <| f ¬∑) := rfl

@[simp high]
theorem int_cast.apply_single [DecidableEq Œπ] (i : Œπ) (x) : int_cast (Pi.single i x) = Pi.single i (Int.cast x) := by
  simp
  ext j
  simp only [Pi.single_apply, Int.cast_ite, Int.cast_zero]

example (a : ‚Ñ§ ‚Üí+ ‚Ñù) : ‚Ñ§ ‚Üí‚Çó[‚Ñ§] ‚Ñù := by exact a.toIntLinearMap
#check AddMonoidHom.toIntLinearMap

#check (1 : Matrix ‚Ñ§ ‚Ñ§ ‚Ñù)
-- def int_axes (Œπ : Type*) : Basis Œπ ‚Ñ§ (Œπ ‚Üí ‚Ñ§) where repr := LinearEquiv.refl
-- def int_axes (Œπ : Type*) [DecidableEq Œπ] := Set.range (1 : Matrix Œπ Œπ ‚Ñ§).col
def int_axes (Œπ : Type*) [Fintype Œπ] [DecidableEq Œπ] : Set (Œπ ‚Üí ‚Ñ§) := Set.range (Pi.single ¬∑ 1)

-- lemma int_axes.decomposition [Fintype Œπ] [DecidableEq Œπ] : int_axes Œπ

-- #check AddSubgroup.mem_closure_range_iff_of_fintype
theorem int_axes.basis [Fintype Œπ]  [DecidableEq Œπ] : AddSubgroup.closure (int_axes Œπ) = ‚ä§ := by
  ext x
  simp only [AddSubgroup.mem_top, iff_true]
  apply AddSubgroup.mem_closure_range_iff_of_fintype.mpr
  use x
  exact pi_eq_sum_univ' x


-- variable {B' : Matrix}

-- let's revise Zn

def Zn (Œπ : Type*) : AddSubgroup (Œπ ‚Üí ‚Ñù) := int_cast.range

def Zn.axes (Œπ : Type*) [Fintype Œπ] [DecidableEq Œπ] : Set (Œπ ‚Üí ‚Ñù) := int_cast '' (int_axes Œπ)

theorem Zn.axes_basis [Fintype Œπ] [DecidableEq Œπ] : AddSubgroup.closure (Zn.axes Œπ) = Zn Œπ := by
  unfold axes Zn
  rw [AddMonoidHom.range_eq_map,‚Üêint_axes.basis]
  exact Eq.symm (AddMonoidHom.map_closure int_cast (int_axes Œπ))


-- should I generalize further? there was ‚Ñ§‚Çê‚Åø

#check Pi.intCast_def

-- def Zn.general (Œπ : Type*) (R : Type*) [IntCast R] : Set (Œπ ‚Üí R) := Set.range ((Int.cast : ‚Ñ§ ‚Üí R) ‚àò ¬∑)





#check PMF.bind_map



def ùìõ.ofMatrix (B : Matrix Œπ n ‚Ñù) :=  (Zn n).map (B.mulVecLin : (n ‚Üí ‚Ñù) ‚Üí+ (Œπ ‚Üí ‚Ñù))


#check B.mulVecLin


theorem ùìõ.ofMatrix_def (B : Matrix Œπ n ‚Ñù)
  -- : ùìõ.ofMatrix B = (B.mulVec) '' (Set.range ((Int.cast <| ¬∑ ¬∑) : (_ ‚Üí _) ‚Üí _)) := rfl
  -- : ùìõ.ofMatrix B = Set.range (B.mulVec <| ((Int.cast <| ¬∑ ¬∑) : (_ ‚Üí _) ‚Üí _) ¬∑) := by
  : ùìõ.ofMatrix B = Set.range (fun x : _ ‚Üí _ ‚Ü¶ B.mulVec (Int.cast <| x ¬∑) ) := by
    sorry

theorem ùìõ.ofMatrix_def_comp (B : Matrix Œπ n ‚Ñù)
  : ùìõ.ofMatrix B = ( (B.mulVecLin.toAddMonoidHom).comp (int_cast) ).range := by
    sorry

theorem Zn.is_ofMatrix  [Fintype Œπ] [DecidableEq Œπ]  : Zn Œπ = ùìõ.ofMatrix (1 : Matrix Œπ Œπ _) := by
  ext x
  simp only [ùìõ.ofMatrix, Matrix.mulVecLin_one, AddSubgroup.mem_map, AddMonoidHom.coe_coe,
    LinearMap.id_coe, id_eq, exists_eq_right]




#check Matrix.mulVec_add

-- todo: note that the function from (Œπ ‚Üí ‚Ñ§) is a group homomorphism
#check AddMonoidHom

#check Matrix.mulVec.addMonoidHomLeft
#check Matrix.ext_addMonoidHom
-- #check Matrix.addMonoidHom
-- wait I'm an idiot, a matrix as a linear map is Matrix.mulVecLin, I found that already

lemma ùìõ.ofMatrix_is_closure (B : Matrix Œπ n ‚Ñù) : ofMatrix B = AddSubgroup.closure (Set.range B.col) := by
  symm
  apply AddSubgroup.closure_eq_of_le
  ¬∑
    simp [ofMatrix_def_comp]


    intro x ‚ü®xn,xcol‚ü©
    subst xcol
    simp only [Set.mem_range, Function.comp_apply, Matrix.mulVecBilin_apply]

    open scoped Classical in
    use Pi.single xn 1
    simp only [int_cast.apply_single, Int.cast_one, Matrix.mulVec_single, MulOpposite.op_one,
      one_smul]
  simp [ofMatrix]



  sorry

-- theorem ùìõ.ofMatrix_def {Œπ n} [Fintype n] (B : Matrix Œπ n ‚Ñù) : ùìõ.ofMatrix B = (B.mulVec : (n ‚Üí ‚Ñù) ‚Üí (Œπ ‚Üí ‚Ñù)) '' (Zn n)

#check Matrix.mulVec_add


-- todo: note that the function from (Œπ ‚Üí ‚Ñ§) is a group homomorphism
#check AddHom

#check Basis
#check Submodule
#check Submodule.traceDual
-- #check Submodule.traceDual
#check Algebra
-- #check Matrix.mulVec
example : Algebra ‚Ñ§ ‚Ñù := by exact Ring.toIntAlgebra ‚Ñù
#check IsScalarTower
#check Polynomial

#check dotProductEquiv
#check Dual -- not the same as dual lattice

open Function

-- def ùìõ.dualLattice {Œπ : Type*} [Fintype Œπ] (Œõ : Set (Œπ ‚Üí ‚Ñù)) := { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Œõ, dotProduct x v ‚àà Set.range (Int.cast)}
#check neg_involutive
#check Function.Involutive


#check AddSubgroup.map -- use to define ùìõ.ofMatrix

-- #check Real
#check Dual

-- theorem ùìõ.dualLattice_basis  {Œπ n : Type*} [Fintype Œπ] [Fintype n] (B : Matrix Œπ n ‚Ñù)
--   : ùìõ.dualLattice (ùìõ.ofMatrix B) = { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Set.range (B.col), dotProduct x v ‚àà Set.range (Int.cast)} := by
--   sorry

-- wait, sublattices are still n-dimensional? see Corollary 2.8
-- ah, I see. for example 2*Œõ is a sublattice of Œõ, but Œõ with a basis vector removed is not
-- no, nevermind. MG02 defines

#check HomogeneousSubmodule
#check HomogeneousIdeal
#check DirectSum
#check DirectSum.Decomposition
#check Algebra
#check Submodule.IsOrtho
#check Submodule.orthogonal
-- ^^^ would be a subset of a lattice, but it needs [RCLike ùïú]
#check Orthonormal
#check GradedRing

#check TopologicalSpace
def ùìõ.IsLattice (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) : Prop := sorry


def ùìõ.dualLattice_general {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù))  : AddSubgroup (Œπ ‚Üí ‚Ñù) where
  carrier := { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Œõ, x ‚¨ù·µ• v ‚àà S}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]



def ùìõ.dualLattice {Œπ : Type*} [Fintype Œπ] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) : AddSubgroup (Œπ ‚Üí ‚Ñù) := dualLattice_general (Int.castAddHom ‚Ñù |>.range) Œõ


#check Basis.addHaar


theorem ùìõ.dualLattice_involutive  {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) : Involutive (ùìõ.dualLattice_general (Œπ := Œπ) S) := by
  -- unfold Involutive
  intro Œõ

  -- let p (r : ‚Ñù) := (r ‚àà S)
  -- let h (v u : Œπ ‚Üí ‚Ñù) := p (v ‚¨ù·µ• u)


  set Œõ' := dualLattice_general S Œõ with back

  ext x
  rw [AddSubgroup.ext_iff] at back

  unfold dualLattice_general at back ‚ä¢
  change (‚àÄ v ‚àà Œõ', x ‚¨ù·µ• v ‚àà S) ‚Üî x ‚àà Œõ
  change ‚àÄv, v ‚àà Œõ' ‚Üî ‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S at back
  simp_rw [dotProduct_comm x _]
  refine ‚ü®?_,fun xL v vL' ‚Ü¶ (back v).mp vL' x xL‚ü©

  intro fo

  have : ‚àÄv, v ‚àà Œõ' ‚Üí ‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S := by exact fun v a x a_1 ‚Ü¶ a x a_1
  have t2: ‚àÄv, (‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S) ‚Üí v ‚àà Œõ' := by exact fun v a ‚Ü¶ this v (this v (this v (this v a)))

  --  `‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S` means the preimage of (v ‚¨ù·µ•) over S contains Œõ
  -- or that the image over Œõ is in S
  #check AddMonoidHom.range

  let qq (x : Œπ ‚Üí ‚Ñù) := (dotProductBilin ‚Ñ§ ‚Ñ§ x).toAddMonoidHom

  have nne (v : Œπ ‚Üí ‚Ñù): (‚àÄ x ‚àà Œõ, v ‚¨ù·µ• x ‚àà S) ‚Üî Œõ.map (qq v) ‚â§ S := by
    simp [qq]
    constructor
    intro eer
    exact AddSubgroup.map_le_iff_le_comap.mpr (this v (this v (this v (this v eer))))
    intro xee x xL
    rw [AddSubgroup.map_le_iff_le_comap] at xee
    simp_all only [implies_true, Œõ']
    apply xee
    simp_all only
  simp_all only [implies_true]

  sorry

--

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Set (Œπ ‚Üí ‚Ñù))
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà AddSubgroup.closure (Œõ_basis), x ‚¨ù·µ• v ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà (Œõ_basis), x ‚¨ù·µ• v ‚àà S}
  := by
  ext x
  simp only [Set.mem_setOf_eq]

  sorry

-- try dual lattice as a comap

#check dotProductBilin
#check dotProductBilin_apply_apply
#check AddSubgroup.comap
#check dotProductBilin ‚Ñ§ ‚Ñ§

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (v : Œπ ‚Üí ‚Ñù)
  : {x | v ‚¨ù·µ• x ‚àà S} = (v ‚¨ù·µ• ¬∑) ‚Åª¬π' S
  := by rfl
example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (v : Œπ ‚Üí ‚Ñù)
  : {x | v ‚¨ù·µ• x ‚àà S} = (S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by rfl

example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Set (Œπ ‚Üí ‚Ñù))
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà (Œõ_basis), v ‚¨ù·µ• x ‚àà S}
  = ‚®Ö v ‚àà Œõ_basis, (S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by
    ext x
    simp only [Set.mem_setOf_eq, Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]


example {Œπ : Type*} [Fintype Œπ] (S : AddSubgroup ‚Ñù) (Œõ_basis : Finset (Œπ ‚Üí ‚Ñù))
  : ‚®Ö v ‚àà Œõ_basis, ((S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)) : AddSubgroup (Œπ ‚Üí ‚Ñù)).carrier
  = (‚®Ö v ‚àà Œõ_basis, S.comap (dotProductBilin ‚Ñ§ ‚Ñ§ v)).carrier
  := by
    ext x
    simp only [Set.iInf_eq_iInter, Set.mem_iInter, AddSubsemigroup.mem_carrier,
      AddSubmonoid.mem_toSubsemigroup, AddSubgroup.mem_toAddSubmonoid, AddSubgroup.mem_comap,
      AddMonoidHom.coe_coe, dotProductBilin_apply_apply]
    constructor
    intro xw ew ‚ü®G,er‚ü©
    simp_all
    subst er
    simp only [Set.mem_iInter, SetLike.mem_coe]
    intro y eg
    sorry
    sorry

example [Fintype Œπ]  (S : AddSubgroup ‚Ñù)
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ z ‚àà (Zn n), ((B.mulVecLin : (n ‚Üí ‚Ñù) ‚Üí+ (Œπ ‚Üí ‚Ñù)) z) ‚¨ù·µ• x ‚àà S}
  := by
    unfold ùìõ.ofMatrix
    simp only [AddSubgroup.mem_map, AddMonoidHom.coe_coe, Matrix.mulVecBilin_apply,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ]


example [Fintype Œπ]  (S : AddSubgroup ‚Ñù)
  : { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S}
  = { x : Œπ ‚Üí ‚Ñù | ‚àÄ z ‚àà (Zn n), dotProductBilin ‚Ñ§ ‚Ñ§ ((B.mulVecLin) z) x ‚àà S}
  := by
    calc
      {x | ‚àÄ v ‚àà ùìõ.ofMatrix B, v ‚¨ù·µ• x ‚àà S} = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := sorry
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := by rfl
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§).toAddMonoidHom.comp (B.mulVecLin)) z x ‚àà S} := sorry
      _ = {x | ‚àÄ z ‚àà Zn n, ((dotProductBilin ‚Ñ§ ‚Ñ§) (B.mulVecLin z)) x ‚àà S} := sorry

-- right, if all the basis vectors dotprod to ‚Ñ§ then the matrix muls to ‚Ñ§‚Åø

open ProbabilityTheory
open MeasureTheory

#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianPDF


def gaussian [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) (x : Œπ ‚Üí ‚Ñù) := ProbabilityTheory.gaussianPDF 0 s ‚Äñx - c‚Äñ


#check ProbabilityTheory.IsGaussian
#check ProbabilityTheory.isGaussian_map

#check ProbabilityTheory.gaussianReal
#check ProbabilityTheory.gaussianReal _ _ |>.map

#check MeasureTheory.Measure.comap
#check MeasureTheory.Measure.comap_apply

-- we have a function Rn ‚Üí ‚Ñù, and a measure on ‚Ñù

example [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) : gaussian c s = ProbabilityTheory.gaussianPDF 0 s ‚àò (‚Äñ¬∑ - c‚Äñ) := by rfl

#check ProbabilityTheory.gaussianReal
#check MeasureTheory.Measure.withDensity
#check MeasureTheory.Measure.compProd_withDensity
-- look for theorems on this
#check MeasureTheory.pdf_def


#check MeasureTheory.withDensity_pdf_le_map

#check MeasureTheory.pdf

-- nope
example [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := (ProbabilityTheory.gaussianReal 0 s).comap (‚Äñ¬∑ - c‚Äñ) -- nope, not injective.

#check MeasureTheory.pdf



def gaussianMeasure [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := volume.withDensity (gaussianPDF 0 s ‚àò (‚Äñ¬∑ - c‚Äñ))
def gaussianMeasure' [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù)) (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) := gaussianMeasure c s |>.restrict Œõ

def gaussianMeasure'' [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (Œõ : AddSubgroup (Œπ ‚Üí ‚Ñù))  (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0)
  := (gaussianMeasure' Œõ c s Set.univ)‚Åª¬π ‚Ä¢ (gaussianMeasure' Œõ c s)


-- is this true?
-- example  [Fintype Œπ] [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) (s : ‚Ñù‚â•0) : IsGaussian (gaussianMeasure'' c s) := by sorry

#check IsGaussian.toIsProbabilityMeasure

#check IsGaussian.map_eq_gaussianReal



--oh, I found a lattice definition
#check IsZLattice

end s2

namespace s3

open scoped NNReal ENNReal


#check IsZLattice
#check Submodule.IsLattice

abbrev Basis (Œπ : Type*) [Fintype Œπ] := Module.Basis Œπ ‚Ñù (Œπ ‚Üí ‚Ñù)

variable {Œπ : Type*} [Fintype Œπ] (B : Basis Œπ)
variable (Œõ : Submodule ‚Ñ§ (Œπ ‚Üí ‚Ñù)) [DiscreteTopology Œõ] [IsZLattice ‚Ñù Œõ]

section lattices

abbrev ùìõ := Submodule.span ‚Ñ§ (Set.range B)

-- example :=

example : DiscreteTopology (ùìõ B) := ZSpan.instDiscreteTopologySubtypeMemSubmoduleIntSpanRangeCoeBasisRealOfFinite B
example : IsZLattice ‚Ñù (ùìõ B) := by infer_instance
example : Basis Œπ := (IsZLattice.basis Œõ).ofZLatticeBasis ‚Ñù

def dualLattice_basic : AddSubgroup (Œπ ‚Üí ‚Ñù) where
  carrier := { x : Œπ ‚Üí ‚Ñù | ‚àÄ v ‚àà Œõ, x ‚¨ù·µ• v ‚àà (Int.castAddHom ‚Ñù |>.range)}
  add_mem' := by
    intro a b ha hb v hL
    specialize ha v hL
    specialize hb v hL
    rw [add_dotProduct]
    exact AddMemClass.add_mem ha hb
  zero_mem' := by
    simp only [Set.mem_setOf_eq, zero_dotProduct, zero_mem, implies_true]
  neg_mem' := by
    simp only [Set.mem_setOf_eq, neg_dotProduct, neg_mem_iff, imp_self, implies_true]

def dualLattice : Submodule ‚Ñ§ (Œπ ‚Üí ‚Ñù) := (dualLattice_basic Œõ).toIntSubmodule

-- #check ZSpan

def minimum_distance [Norm (Œπ ‚Üí ‚Ñù)] := ‚®Ö (x ‚àà Œõ) (_ : x ‚â† 0), ‚Äñx‚Äñ

/-
paper:
The minimum distance Œª1(Œõ) of a lattice Œõ is the length (in the Euclidean `2 norm, unless otherwise
indicated) of its shortest nonzero vector: Œª1(Œõ) = min06=x‚ààŒõkxk. More generally, the ith successive
minimum Œªi(Œõ) is the smallest radius r such that Œõ contains i linearly independent vectors of norm at
most r. We write Œª‚àû
1
to denote the minimum distance measured in the ‚àû norm (which is defined as ‚Äñx‚Äñ‚àû = max |x·µ¢|).
-/
-- i or more
def successive_minimum_distance [Norm (Œπ ‚Üí ‚Ñù)] (i : ‚Ñï)
  := ‚®Ö (r : ‚Ñù‚â•0) (_ : ‚àÉs ‚äÜ (Œõ.carrier), LinearIndependent ‚Ñù (Subtype.val : s ‚Üí _) ‚àß s.encard ‚â§ i ‚àß ‚àÄx ‚àà s, ‚Äñx‚Äñ ‚â§ r), r
-- note: for i := 0 this is ‚ä• and i := 1 this is 0
def successive_minimum_distance' [Norm (Œπ ‚Üí ‚Ñù)] (i : ‚Ñï)
  := ‚®Ö (s ‚äÜ (Œõ.carrier)) (_ : LinearIndependent ‚Ñù (Subtype.val : s ‚Üí _)) (_ : s.encard ‚â§ i), ‚®Üx ‚àà s, ‚Äñx‚Äñ

-- def dualLattice

end lattices

section gaussians

open ProbabilityTheory
open MeasureTheory


def gaussianFunction [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (_ : s ‚â† 0) (c : Œπ ‚Üí ‚Ñù)  := gaussianPDF 0 s ‚àò (‚Äñ¬∑ - c‚Äñ)

#check MeasureTheory.Measure.count
-- #check Measure.comap

#check gaussianReal
/-
2.4 Gaussians on Lattices
œÅ s c
-/
def gaussianMeasure [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  (c : Œπ ‚Üí ‚Ñù) := Measure.count.withDensity (gaussianFunction hs c)

#check ProbabilityMeasure


def gaussianMeasure' [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0) (c : Œπ ‚Üí ‚Ñù)  := (gaussianMeasure hs c).restrict Œõ


lemma gaussianMeasure'_finite [Norm (Œπ ‚Üí ‚Ñù)]  {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  (c : Œπ ‚Üí ‚Ñù) : IsFiniteMeasure (gaussianMeasure' Œõ hs c) := sorry
-- def gaussianMeasure'_total [Norm (Œπ ‚Üí ‚Ñù)] (c : Œπ ‚Üí ‚Ñù) {s : ‚Ñù‚â•0} (hs : s ‚â† 0) := (gaussianMeasure' Œõ c hs) Set.univ

-- def gaussianDistribution [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  (c : Œπ ‚Üí ‚Ñù) := ((gaussianMeasure' Œõ hs c) Set.univ)‚Åª¬π ‚Ä¢ gaussianMeasure' Œõ hs c
def gaussianDistribution [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  (c : Œπ ‚Üí ‚Ñù) := (gaussianMeasure' Œõ hs c)[|Set.univ]

lemma gaussianDistribution_prob [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0) (c : Œπ ‚Üí ‚Ñù) : IsProbabilityMeasure (gaussianDistribution Œõ hs c) := by
  unfold gaussianDistribution
  -- refine cond_isProbabilityMeasure ?_
  refine isProbabilityMeasure_iff.mpr ?_
  simp only [ProbabilityTheory.cond, Measure.restrict_univ, Measure.smul_apply, smul_eq_mul]
  refine ENNReal.inv_mul_cancel ?_ ?_
  -- todo: make its own theorem
  simp only [ne_eq, Measure.measure_univ_eq_zero]
  intro gm
  rw [Measure.ext_iff] at gm
  specialize gm {0}
  simp only [MeasurableSet.singleton, Measure.coe_zero, Pi.ofNat_apply, forall_const] at gm
  unfold gaussianMeasure' gaussianMeasure at gm
  have : {0} ‚à© (Œõ : Set (Œπ ‚Üí ‚Ñù)) = {0} := by
    rw [Set.inter_eq_left, Set.singleton_subset_iff, SetLike.mem_coe]
    exact zero_mem Œõ

  simp only [MeasurableSet.singleton, Measure.restrict_apply, this, withDensity_apply,
    Measure.restrict_singleton, Measure.count_singleton', one_smul, lintegral_dirac] at gm
  unfold gaussianFunction gaussianPDF at gm
  simp at gm
  revert gm
  simp only [imp_false, not_le]
  exact gaussianPDFReal_pos _ _ _ hs

  have := gaussianMeasure'_finite Œõ hs c
  exact this.1.ne


lemma gaussianDistribution.eq [Norm (Œπ ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  (c : Œπ ‚Üí ‚Ñù)
  : gaussianDistribution Œõ hs c = (gaussianMeasure hs c)[|Œõ] := by
    unfold gaussianDistribution gaussianMeasure'
    simp only [ProbabilityTheory.cond, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter,
      Measure.restrict_univ]


def int_gaussian_real_measure (m) [Norm (Fin m ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  : Measure (Fin m ‚Üí ‚Ñù)
  :=
  gaussianDistribution (AddSubgroup.toIntSubmodule (s2.Zn (Fin m))) hs 0



-- def int_gaussian_int_measure (m) [Norm (Fin m ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  : Measure (Fin m ‚Üí ‚Ñ§)
--   :=  (gaussianMeasure hs 0)[| (s2.Zn (Fin m))].comap ((‚Üë) ‚àò ¬∑)
def int_gaussian_int_measure (m) [Norm (Fin m ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (hs : s ‚â† 0)  : Measure (Fin m ‚Üí ‚Ñ§)
  :=  ((gaussianMeasure hs 0).comap ((Int.cast : ‚Ñ§ ‚Üí ‚Ñù) ‚àò ¬∑))[|Set.univ]

def int_gaussian  (m) [Norm (Fin m ‚Üí ‚Ñù)] {s : ‚Ñù‚â•0} (h : s ‚â† 0)  : ProbabilityMeasure (Fin m ‚Üí ‚Ñ§) :=
  ‚ü®
    int_gaussian_int_measure m h
    , sorry
  ‚ü©


end gaussians


def smoothing_parameter {Œµ : ‚Ñù‚â•0} (_ : Œµ ‚â† 0)
  := ‚®Ö (s : ‚Ñù‚â•0) (hs : s ‚â† 0) (_ : (gaussianMeasure' (dualLattice Œõ) (show s‚Åª¬π ‚â† 0 by simp only [ne_eq,
    inv_eq_zero, hs, not_false_eq_true]) 0) (Set.compl {0}) ‚â§ Œµ), s

def infinity_norm : Norm (Œπ ‚Üí ‚Ñù) := ‚ü®fun x ‚Ü¶ (PiLp.instNorm ‚àû (fun (_ : Œπ) ‚Ü¶ ‚Ñù)).norm (WithLp.toLp ‚àû x)‚ü©

-- what log base?
lemma Lemma_2_6 {Œµ : ‚Ñù‚â•0} (he : Œµ ‚â† 0)
  : smoothing_parameter Œõ he ‚â§
  ‚àö (Real.log (2 * Fintype.card Œπ / (1 + Œµ‚Åª¬π)) / Real.pi)
  / @minimum_distance Œπ Œõ (infinity_norm) := sorry
-- find infinity-norm

#check EuclideanSpace

-- todo: Norm is just a notation class. theorems about defs using it need [NormedAddCommGroup]
#check NormedAddCommGroup

#check ForIn

#check Monad

def SampleD {n : ‚Ñï} {m : ‚Ñï} (hn : 0 < n) (gs_b : Basis (Fin n)) (s : ‚Ñù‚â•0) (hs : s ‚â† 0) (center : (Fin n) ‚Üí ‚Ñù) (DZ : {s' : ‚Ñù // s' > 0} ‚Üí ‚Ñù ‚Üí PMF (‚Ñ§)) : PMF ( Fin n ‚Üí ‚Ñù)  := do {
  let mut v : ((Fin n) ‚Üí ‚Ñù)  := 0;
  let mut c : ((Fin n) ‚Üí ‚Ñù) := center;

  for hi : i in (Vector.range n).reverse do
    let fi : Fin n := ‚ü®i,(Vector.mem_range.mp (Vector.mem_reverse.mp hi))‚ü©
    let bi := gs_b fi
    let c'i : ‚Ñù := (c ‚¨ù·µ• bi) / (bi ‚¨ù·µ• bi);
    let s'i : ‚Ñù := s / ‚Äñbi‚Äñ;
    have : s'i > 0 := by sorry;
    -- step (b)
    let zi ‚Üê (DZ ‚ü®s'i,this‚ü© c'i);
    -- step (c)
    c := (c - zi ‚Ä¢ bi)
    v := (v + zi ‚Ä¢ bi)

  return v
}

#check Asymptotics.IsLittleO
open Asymptotics MeasureTheory

def negligible {R : Type*} [Norm R] (f : ‚Ñï ‚Üí R) := ‚àÄ(c : ‚Ñï), c > 0 ‚Üí f =o[Filter.atTop] (fun (n : ‚Ñï) ‚Ü¶ (n : ‚Ñù) ^ (-(c : ‚Ñù)))

-- #check ProbabilityTheory.HasPDF
#check MeasureTheory.pdf

--- [https://www.cs.bu.edu/~reyzin/teaching/s11cs937/notes-leo-1.pdf]


#check PMF


#check MeasureTheory.SignedMeasure.totalVariation -- Gemini found this.


-- I need to explain this
def statistical_distance' {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D) := (2‚Åª¬π) * (SignedMeasure.totalVariation (X.toMeasure.toSignedMeasure - Y.toMeasure.toSignedMeasure)) Set.univ
lemma statistical_distance_finite_1 {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D)
  : IsFiniteMeasure ((X.toMeasure.toSignedMeasure - Y.toMeasure.toSignedMeasure).totalVariation) := isFiniteMeasureAdd
lemma statistical_distance_finite_2 {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D)
  : statistical_distance' X Y < ‚àû := by
    unfold statistical_distance'
    refine ENNReal.mul_lt_top ?_ ?_
    simp only [ENNReal.inv_lt_top, Nat.ofNat_pos]
    simp only [statistical_distance_finite_1, measure_lt_top]
def statistical_distance {D : Type*} [MeasurableSpace D] (X Y : ProbabilityMeasure D) : ‚Ñù‚â•0 := statistical_distance' X Y |>.toNNReal


def statistically_close {D : Type*} [MeasurableSpace D] (X Y : ‚Ñï ‚Üí ProbabilityMeasure D) :=
  let _ : Norm ‚Ñù‚â•0 := ‚ü®(‚Üë)‚ü©;
  negligible (fun n ‚Ü¶ statistical_distance (X n) (Y n))


-- theorem lemma_5_1 {m : ‚Ñù‚â•0} {_ : 2 * n }

-- #check Mathlib.Testing.SlimCheck

def mHyp (m n q : ‚Ñï) : Prop := (2 * n * Real.log q) ‚â§ m


-- #check ZMod 2
-- def mod_q ( q : ‚Ñï) := ‚Ñ§ ‚ß∏ (AddSubgroup.closure {(q : ‚Ñ§)})
-- lemma mod_q.isFinite {q : ‚Ñï} : Finite (ZMod q) := by
--   apply?
--   sorry

-- seems like Fin q is the integers mod q
#eval (7 : Fin 6)
-- ZMod q is Fin q if q is positive

-- abbrev mod_q ( q : ‚Ñï) := ZMod q


-- note: NeZero allows this to be inferred, while h : q > 0 doesn't
example  {q : ‚Ñï} [NeZero q] : Finite (ZMod q) := inferInstance

-- instance {q : ‚Ñï} : Zero (ZMod q) where zero := 0

def A_Matrix (n m q : ‚Ñï) : Type := Matrix (Fin n) (Fin m) (ZMod q)

instance A_Matrix.instFinite {n m q : ‚Ñï} [NeZero q] : Finite (A_Matrix n m q) := Matrix.instFinite (ZMod q)
instance {n m q : ‚Ñï} [NeZero q] : Nonempty (A_Matrix n m q) := Equiv.nonempty Matrix.of.symm

-- set_option trace.Meta.synthInstance true in
example (q)  [NeZero q] : Algebra ‚Ñ§ (ZMod q) := inferInstance

def toZModLin (q) : ‚Ñ§ ‚Üí‚Çó[‚Ñ§] (ZMod q) := Algebra.linearMap ‚Ñ§ (ZMod q)

#eval
  (List.range 10).map ((‚Üë) : _ ‚Üí ‚Ñ§) |>.map (toZModLin 3)

def A_Matrix.syndrome_map {n m q : ‚Ñï} (A : A_Matrix n m q) : (Fin m ‚Üí ‚Ñ§) ‚Üí‚Çó[‚Ñ§] (Fin n ‚Üí ZMod q) := by
  -- have := Matrix.toLin (m := Fin n) (n := Fin m) (R := ZMod q) sorry sorry
  let vl:= Matrix.mulVecLin A
  -- have this be ‚Üí‚Çó[‚Ñ§] as well
  -- is converting to ZMod q the same before or after "this"?
  let : (Fin m ‚Üí ‚Ñ§) ‚Üí‚Çó[‚Ñ§] (Fin m ‚Üí ZMod q) := by
    exact (toZModLin q).compLeft (Fin m)
  exact Fintype.linearCombination ‚Ñ§ fun a a_1 ‚Ü¶ A a_1 a

  -- refine ((LinearMap.comp this vl) )


-- this shows that modulo can be done before or after
example (q : ‚Ñï) (a b : ‚Ñ§) : ((a : ZMod q) * (b : ZMod q)) = ‚Üë(a * b) := by
  simp only [Int.cast_mul]

def A_Matrix.syndrome_map' {n m q : ‚Ñï} (A : A_Matrix n m q) : (Fin m ‚Üí ‚Ñ§) ‚Üí (Fin n ‚Üí ZMod q) := by
  intro x
  apply A.mulVec
  exact Int.cast ‚àò x

section testing
open Plausible



instance {q} : Arbitrary (ZMod q) :=
  match q with
    | 0 => Int.Arbitrary
    | _ + 1 => Fin.Arbitrary
instance {q} : Shrinkable (ZMod q) :=
  match q with
    | 0 => Int.shrinkable
    | _ + 1 => Fin.shrinkable
#test ‚àÄi : (ZMod 5), i + 0 = i
#test ‚àÄi : (Fin 2 ‚Üí Fin 2), i + 0 = i

-- experimentally checks that syndrome_map is correct
#eval Testable.check
    (‚àÄ ee : _ ‚Üí _ ‚Üí (ZMod _),
    let A : A_Matrix 3 4 5 := Matrix.of ee;
    ‚àÄxx, A.syndrome_map xx = A.syndrome_map' xx)
  {traceSuccesses := true}



end testing

#check DiscreteMeasurableSpace
-- #check OpensMeasurableSpace

instance A_Matrix.instMeasurableSpace (n m q : ‚Ñï) [NeZero q] : MeasurableSpace (A_Matrix n m q) := ‚ä§
example (n m q : ‚Ñï) [NeZero q] : DiscreteMeasurableSpace (A_Matrix n m q) := inferInstance

def A_Matrix.uniform (n m q : ‚Ñï) [NeZero q] : ProbabilityMeasure (A_Matrix n m q) :=
  ‚ü®ProbabilityTheory.uniformOn Set.univ,
  ProbabilityTheory.uniformOn_isProbabilityMeasure Set.finite_univ Set.univ_nonempty‚ü©

instance {n m q : ‚Ñï} [NeZero q] : MeasureSpace (A_Matrix n m q) where
  volume := A_Matrix.uniform n m q


def uniform_over_Zqn (n q : ‚Ñï) [NeZero q] : ProbabilityMeasure (Fin n ‚Üí ZMod q) :=
  ‚ü®ProbabilityTheory.uniformOn Set.univ,
  ProbabilityTheory.uniformOn_isProbabilityMeasure Set.finite_univ Set.univ_nonempty‚ü©

#check ProbabilityTheory.uniformOn_univ


#check int_gaussian


-- "the subset-sums of the columns of A generate Zqn"
def lemma_5_1_statement {n m q : ‚Ñï} (A : A_Matrix n m q) : Prop :=
  A.syndrome_map '' {e | ‚àÄi, e i = 0 ‚à® e i = 1} = Set.univ

-- the form seems complete
theorem lemma_5_1 {n m q : ‚Ñï} [NeZero q]  (q_prime : Nat.Prime q) (m_hyp : mHyp m n q) : volume (@lemma_5_1_statement n m q) ‚â§ (q ^ (- n : ‚Ñù)) := sorry




-- hmm, in Corollary 5.4, "statistically close" describes what happens as n varies, but A is conditioned on n. this means statistically_close does not fit
-- what does it mean?

-- the distribution of the syndrome is statistically close to uniform
-- statistically close = statistical distance is negligible in n
-- blackboard: (A, Ax mod q) ‚âà (A, y)     f m ‚â• ...
-- is it expressed that the distribution sampled from (A : Uniform,e : Gaussian) to (A, Ae mod q), is compared to the distribution (A : Uniform, y: Uniform),
--  and these distributions have type [ProbabilityMeasure ()]
#check let n :=5; let m := 7; let q := 10;
  ProbabilityMeasure ((A_Matrix n m q) √ó (Fin n ‚Üí ZMod q))


def corollary_5_4_statement {n m q : ‚Ñï} (A : Matrix (Fin n) (Fin m) (ZMod q)) (s : ‚Ñù) : Prop := sorry

theorem corollary_5_4 {n m q : ‚Ñï} (q_prime : Nat.Prime q) (m_hyp : mHyp m n q) : False := sorry


def mHyp' (m q : ‚Ñï ‚Üí ‚Ñï) : Prop := ‚àÄn, (2 * n * Real.log (q n)) ‚â§ m n

theorem corollary_5_4_gen (q : ‚Ñï ‚Üí ‚Ñï)  (m : ‚Ñï ‚Üí ‚Ñï) (q_hyp : ‚àÄn, Nat.Prime (q n)) (m_hyp : mHyp' m q) : False := sorry
